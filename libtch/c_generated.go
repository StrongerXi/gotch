/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT BY HAND! */
#[allow(clippy::all)]
use crate::{C_scalar, C_tensor};
use libc::c_int;

extern "C" {
    func atg___and__(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg___and__1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg___iand__(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg___iand__1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg___ilshift__(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg___ilshift__1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg___ior__(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg___ior__1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg___irshift__(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg___irshift__1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg___ixor__(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg___ixor__1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg___lshift__(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg___lshift__1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg___or__(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg___or__1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg___rshift__(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg___rshift__1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg___xor__(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg___xor__1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg__adaptive_avg_pool2d(out__: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int);
    func atg__adaptive_avg_pool2d_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor);
    func atg__addr(out__: *C_tensor, self_: *C_tensor, vec1_: *C_tensor, vec2_: *C_tensor);
    func atg__addr_(out__: *C_tensor, self_: *C_tensor, vec1_: *C_tensor, vec2_: *C_tensor);
    func atg__addr_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, vec1_: *C_tensor, vec2_: *C_tensor);
    func atg__amp_update_scale(out__: *C_tensor, growth_tracker_: *C_tensor, current_scale_: *C_tensor, found_inf_: *C_tensor, scale_growth_factor_: float64, scale_backoff_factor_: float64, growth_interval_: int64);
    func atg__baddbmm_mkl_(out__: *C_tensor, self_: *C_tensor, batch1_: *C_tensor, batch2_: *C_tensor);
    func atg__cast_byte(out__: *C_tensor, self_: *C_tensor, non_blocking_: c_int);
    func atg__cast_char(out__: *C_tensor, self_: *C_tensor, non_blocking_: c_int);
    func atg__cast_double(out__: *C_tensor, self_: *C_tensor, non_blocking_: c_int);
    func atg__cast_float(out__: *C_tensor, self_: *C_tensor, non_blocking_: c_int);
    func atg__cast_half(out__: *C_tensor, self_: *C_tensor, non_blocking_: c_int);
    func atg__cast_int(out__: *C_tensor, self_: *C_tensor, non_blocking_: c_int);
    func atg__cast_long(out__: *C_tensor, self_: *C_tensor, non_blocking_: c_int);
    func atg__cast_short(out__: *C_tensor, self_: *C_tensor, non_blocking_: c_int);
    func atg__cat(out__: *C_tensor, tensors_data *C_tensor, tensors_len c_int, dim_: int64);
    func atg__cat_out(out__: *C_tensor, out_: *C_tensor, tensors_data *C_tensor, tensors_len c_int, dim_: int64);
    func atg__cdist_backward(out__: *C_tensor, grad_: *C_tensor, x1_: *C_tensor, x2_: *C_tensor, p_: float64, cdist_: *C_tensor);
    func atg__cholesky_helper(out__: *C_tensor, self_: *C_tensor, upper_: c_int);
    func atg__cholesky_solve_helper(out__: *C_tensor, self_: *C_tensor, A_: *C_tensor, upper_: c_int);
    func atg__coalesced_(out__: *C_tensor, self_: *C_tensor, coalesced_: c_int);
    func atg__convolution(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, transposed_: c_int, output_padding_data int64, output_padding_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int, cudnn_enabled_: c_int);
    func atg__convolution_nogroup(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, transposed_: c_int, output_padding_data int64, output_padding_len c_int);
    func atg__copy_from(out__: *C_tensor, self_: *C_tensor, dst_: *C_tensor, non_blocking_: c_int);
    func atg__ctc_loss(out__: *C_tensor, log_probs_: *C_tensor, targets_: *C_tensor, input_lengths_data int64, input_lengths_len c_int, target_lengths_data int64, target_lengths_len c_int, blank_: int64, zero_infinity_: c_int);
    func atg__ctc_loss_backward(out__: *C_tensor, grad_: *C_tensor, log_probs_: *C_tensor, targets_: *C_tensor, input_lengths_data int64, input_lengths_len c_int, target_lengths_data int64, target_lengths_len c_int, neg_log_likelihood_: *C_tensor, log_alpha_: *C_tensor, blank_: int64, zero_infinity_: c_int);
    func atg__cudnn_ctc_loss(out__: *C_tensor, log_probs_: *C_tensor, targets_: *C_tensor, input_lengths_data int64, input_lengths_len c_int, target_lengths_data int64, target_lengths_len c_int, blank_: int64, deterministic_: c_int, zero_infinity_: c_int);
    func atg__cudnn_init_dropout_state(out__: *C_tensor, dropout_: float64, train_: c_int, dropout_seed_: int64, options_kind c_int, options_device c_int);
    func atg__cudnn_rnn(out__: *C_tensor, input_: *C_tensor, weight_data *C_tensor, weight_len c_int, weight_stride0_: int64, weight_buf_: *C_tensor, hx_: *C_tensor, cx_: *C_tensor, mode_: int64, hidden_size_: int64, num_layers_: int64, batch_first_: c_int, dropout_: float64, train_: c_int, bidirectional_: c_int, batch_sizes_data int64, batch_sizes_len c_int, dropout_state_: *C_tensor);
    func atg__cudnn_rnn_flatten_weight(out__: *C_tensor, weight_arr_data *C_tensor, weight_arr_len c_int, weight_stride0_: int64, input_size_: int64, mode_: int64, hidden_size_: int64, num_layers_: int64, batch_first_: c_int, bidirectional_: c_int);
    func atg__cumprod(out__: *C_tensor, self_: *C_tensor, dim_: int64);
    func atg__cumprod_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, dim_: int64);
    func atg__cumsum(out__: *C_tensor, self_: *C_tensor, dim_: int64);
    func atg__cumsum_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, dim_: int64);
    func atg__dim_arange(out__: *C_tensor, like_: *C_tensor, dim_: int64);
    func atg__dirichlet_grad(out__: *C_tensor, x_: *C_tensor, alpha_: *C_tensor, total_: *C_tensor);
    func atg__embedding_bag(out__: *C_tensor, weight_: *C_tensor, indices_: *C_tensor, offsets_: *C_tensor, scale_grad_by_freq_: c_int, mode_: int64, sparse_: c_int, per_sample_weights_: *C_tensor, include_last_offset_: c_int);
    func atg__embedding_bag_backward(out__: *C_tensor, grad_: *C_tensor, indices_: *C_tensor, offsets_: *C_tensor, offset2bag_: *C_tensor, bag_size_: *C_tensor, maximum_indices_: *C_tensor, num_weights_: int64, scale_grad_by_freq_: c_int, mode_: int64, sparse_: c_int, per_sample_weights_: *C_tensor);
    func atg__embedding_bag_dense_backward(out__: *C_tensor, grad_: *C_tensor, indices_: *C_tensor, offsets_: *C_tensor, offset2bag_: *C_tensor, bag_size_: *C_tensor, maximum_indices_: *C_tensor, num_weights_: int64, scale_grad_by_freq_: c_int, mode_: int64, per_sample_weights_: *C_tensor);
    func atg__embedding_bag_per_sample_weights_backward(out__: *C_tensor, grad_: *C_tensor, weight_: *C_tensor, indices_: *C_tensor, offsets_: *C_tensor, offset2bag_: *C_tensor, mode_: int64);
    func atg__embedding_bag_sparse_backward(out__: *C_tensor, grad_: *C_tensor, indices_: *C_tensor, offsets_: *C_tensor, offset2bag_: *C_tensor, bag_size_: *C_tensor, num_weights_: int64, scale_grad_by_freq_: c_int, mode_: int64, per_sample_weights_: *C_tensor);
    func atg__empty_affine_quantized(out__: *C_tensor, size_data int64, size_len c_int, options_kind c_int, options_device c_int, scale_: float64, zero_point_: int64);
    func atg__empty_per_channel_affine_quantized(out__: *C_tensor, size_data int64, size_len c_int, scales_: *C_tensor, zero_points_: *C_tensor, axis_: int64, options_kind c_int, options_device c_int);
    func atg__fft_with_size(out__: *C_tensor, self_: *C_tensor, signal_ndim_: int64, complex_input_: c_int, complex_output_: c_int, inverse_: c_int, checked_signal_sizes_data int64, checked_signal_sizes_len c_int, normalized_: c_int, onesided_: c_int, output_sizes_data int64, output_sizes_len c_int);
    func atg__fused_dropout(out__: *C_tensor, self_: *C_tensor, p_: float64);
    func atg__gather_sparse_backward(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, grad_: *C_tensor);
    func atg__index_copy_(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, source_: *C_tensor);
    func atg__index_put_impl_(out__: *C_tensor, self_: *C_tensor, indices_data *C_tensor, indices_len c_int, values_: *C_tensor, accumulate_: c_int, unsafe_: c_int);
    func atg__indices(out__: *C_tensor, self_: *C_tensor);
    func atg__inverse_helper(out__: *C_tensor, self_: *C_tensor);
    func atg__log_softmax(out__: *C_tensor, self_: *C_tensor, dim_: int64, half_to_float_: c_int);
    func atg__log_softmax_backward_data(out__: *C_tensor, grad_output_: *C_tensor, output_: *C_tensor, dim_: int64, self_: *C_tensor);
    func atg__lu_solve_helper(out__: *C_tensor, self_: *C_tensor, LU_data_: *C_tensor, LU_pivots_: *C_tensor);
    func atg__lu_with_info(out__: *C_tensor, self_: *C_tensor, pivot_: c_int, check_errors_: c_int);
    func atg__make_per_channel_quantized_tensor(out__: *C_tensor, self_: *C_tensor, scale_: *C_tensor, zero_point_: *C_tensor, axis_: int64);
    func atg__make_per_tensor_quantized_tensor(out__: *C_tensor, self_: *C_tensor, scale_: float64, zero_point_: int64);
    func atg__masked_scale(out__: *C_tensor, self_: *C_tensor, mask_: *C_tensor, scale_: float64);
    func atg__max(out__: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg__max_out(out__: *C_tensor, max_: *C_tensor, max_indices_: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg__min(out__: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg__min_out(out__: *C_tensor, min_: *C_tensor, min_indices_: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg__mkldnn_reshape(out__: *C_tensor, self_: *C_tensor, shape_data int64, shape_len c_int);
    func atg__mkldnn_transpose(out__: *C_tensor, self_: *C_tensor, dim0_: int64, dim1_: int64);
    func atg__mkldnn_transpose_(out__: *C_tensor, self_: *C_tensor, dim0_: int64, dim1_: int64);
    func atg__mode(out__: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg__mode_out(out__: *C_tensor, values_: *C_tensor, indices_: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg__multinomial_alias_draw(out__: *C_tensor, J_: *C_tensor, q_: *C_tensor, num_samples_: int64);
    func atg__multinomial_alias_setup(out__: *C_tensor, probs_: *C_tensor);
    func atg__nnpack_spatial_convolution(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int);
    func atg__nnpack_spatial_convolution_backward_input(out__: *C_tensor, input_: *C_tensor, grad_output_: *C_tensor, weight_: *C_tensor, padding_data int64, padding_len c_int);
    func atg__nnpack_spatial_convolution_backward_weight(out__: *C_tensor, input_: *C_tensor, weightsize_data int64, weightsize_len c_int, grad_output_: *C_tensor, padding_data int64, padding_len c_int);
    func atg__pack_padded_sequence(out__: *C_tensor, input_: *C_tensor, lengths_: *C_tensor, batch_first_: c_int);
    func atg__pack_padded_sequence_backward(out__: *C_tensor, grad_: *C_tensor, input_size_data int64, input_size_len c_int, batch_sizes_: *C_tensor, batch_first_: c_int);
    func atg__pad_packed_sequence(out__: *C_tensor, data_: *C_tensor, batch_sizes_: *C_tensor, batch_first_: c_int, padding_value_: *C_scalar, total_length_: int64);
    func atg__pdist_backward(out__: *C_tensor, grad_: *C_tensor, self_: *C_tensor, p_: float64, pdist_: *C_tensor);
    func atg__qr_helper(out__: *C_tensor, self_: *C_tensor, some_: c_int);
    func atg__reshape_from_tensor(out__: *C_tensor, self_: *C_tensor, shape_: *C_tensor);
    func atg__s_where(out__: *C_tensor, condition_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg__sample_dirichlet(out__: *C_tensor, self_: *C_tensor);
    func atg__shape_as_tensor(out__: *C_tensor, self_: *C_tensor);
    func atg__sobol_engine_draw(out__: *C_tensor, quasi_: *C_tensor, n_: int64, sobolstate_: *C_tensor, dimension_: int64, num_generated_: int64, dtype_: c_int);
    func atg__sobol_engine_ff_(out__: *C_tensor, self_: *C_tensor, n_: int64, sobolstate_: *C_tensor, dimension_: int64, num_generated_: int64);
    func atg__sobol_engine_initialize_state_(out__: *C_tensor, self_: *C_tensor, dimension_: int64);
    func atg__sobol_engine_scramble_(out__: *C_tensor, self_: *C_tensor, ltm_: *C_tensor, dimension_: int64);
    func atg__softmax(out__: *C_tensor, self_: *C_tensor, dim_: int64, half_to_float_: c_int);
    func atg__softmax_backward_data(out__: *C_tensor, grad_output_: *C_tensor, output_: *C_tensor, dim_: int64, self_: *C_tensor);
    func atg__solve_helper(out__: *C_tensor, self_: *C_tensor, A_: *C_tensor);
    func atg__sparse_addmm(out__: *C_tensor, self_: *C_tensor, sparse_: *C_tensor, dense_: *C_tensor);
    func atg__sparse_coo_tensor_unsafe(out__: *C_tensor, indices_: *C_tensor, values_: *C_tensor, size_data int64, size_len c_int, options_kind c_int, options_device c_int);
    func atg__sparse_coo_tensor_with_dims(out__: *C_tensor, sparse_dim_: int64, dense_dim_: int64, size_data int64, size_len c_int, options_kind c_int, options_device c_int);
    func atg__sparse_coo_tensor_with_dims_and_tensors(out__: *C_tensor, sparse_dim_: int64, dense_dim_: int64, size_data int64, size_len c_int, indices_: *C_tensor, values_: *C_tensor, options_kind c_int, options_device c_int);
    func atg__sparse_mm(out__: *C_tensor, sparse_: *C_tensor, dense_: *C_tensor);
    func atg__sparse_sum(out__: *C_tensor, self_: *C_tensor);
    func atg__sparse_sum1(out__: *C_tensor, self_: *C_tensor, dtype_: c_int);
    func atg__sparse_sum2(out__: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int);
    func atg__sparse_sum3(out__: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, dtype_: c_int);
    func atg__sparse_sum_backward(out__: *C_tensor, grad_: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int);
    func atg__standard_gamma(out__: *C_tensor, self_: *C_tensor);
    func atg__standard_gamma_grad(out__: *C_tensor, self_: *C_tensor, output_: *C_tensor);
    func atg__std(out__: *C_tensor, self_: *C_tensor, unbiased_: c_int);
    func atg__svd_helper(out__: *C_tensor, self_: *C_tensor, some_: c_int, compute_uv_: c_int);
    func atg__symeig_helper(out__: *C_tensor, self_: *C_tensor, eigenvectors_: c_int, upper_: c_int);
    func atg__triangular_solve_helper(out__: *C_tensor, self_: *C_tensor, A_: *C_tensor, upper_: c_int, transpose_: c_int, unitriangular_: c_int);
    func atg__trilinear(out__: *C_tensor, i1_: *C_tensor, i2_: *C_tensor, i3_: *C_tensor, expand1_data int64, expand1_len c_int, expand2_data int64, expand2_len c_int, expand3_data int64, expand3_len c_int, sumdim_data int64, sumdim_len c_int, unroll_dim_: int64);
    func atg__unique(out__: *C_tensor, self_: *C_tensor, sorted_: c_int, return_inverse_: c_int);
    func atg__unique2(out__: *C_tensor, self_: *C_tensor, sorted_: c_int, return_inverse_: c_int, return_counts_: c_int);
    func atg__unsafe_view(out__: *C_tensor, self_: *C_tensor, size_data int64, size_len c_int);
    func atg__values(out__: *C_tensor, self_: *C_tensor);
    func atg__var(out__: *C_tensor, self_: *C_tensor, unbiased_: c_int);
    func atg__weight_norm(out__: *C_tensor, v_: *C_tensor, g_: *C_tensor, dim_: int64);
    func atg__weight_norm_cuda_interface(out__: *C_tensor, v_: *C_tensor, g_: *C_tensor, dim_: int64);
    func atg__weight_norm_cuda_interface_backward(out__: *C_tensor, grad_w_: *C_tensor, saved_v_: *C_tensor, saved_g_: *C_tensor, saved_norms_: *C_tensor, dim_: int64);
    func atg__weight_norm_differentiable_backward(out__: *C_tensor, grad_w_: *C_tensor, saved_v_: *C_tensor, saved_g_: *C_tensor, saved_norms_: *C_tensor, dim_: int64);
    func atg_abs(out__: *C_tensor, self_: *C_tensor);
    func atg_abs_(out__: *C_tensor, self_: *C_tensor);
    func atg_abs_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_acos(out__: *C_tensor, self_: *C_tensor);
    func atg_acos_(out__: *C_tensor, self_: *C_tensor);
    func atg_acos_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_adaptive_avg_pool1d(out__: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int);
    func atg_adaptive_avg_pool2d(out__: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int);
    func atg_adaptive_avg_pool2d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int);
    func atg_adaptive_avg_pool3d(out__: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int);
    func atg_adaptive_avg_pool3d_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor);
    func atg_adaptive_avg_pool3d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor);
    func atg_adaptive_avg_pool3d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int);
    func atg_adaptive_max_pool1d(out__: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int);
    func atg_adaptive_max_pool2d(out__: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int);
    func atg_adaptive_max_pool2d_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, indices_: *C_tensor);
    func atg_adaptive_max_pool2d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, indices_: *C_tensor);
    func atg_adaptive_max_pool2d_out(out__: *C_tensor, out_: *C_tensor, indices_: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int);
    func atg_adaptive_max_pool3d(out__: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int);
    func atg_adaptive_max_pool3d_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, indices_: *C_tensor);
    func atg_adaptive_max_pool3d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, indices_: *C_tensor);
    func atg_adaptive_max_pool3d_out(out__: *C_tensor, out_: *C_tensor, indices_: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int);
    func atg_add(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_add1(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_add_(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_add_1(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_add_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_addbmm(out__: *C_tensor, self_: *C_tensor, batch1_: *C_tensor, batch2_: *C_tensor);
    func atg_addbmm_(out__: *C_tensor, self_: *C_tensor, batch1_: *C_tensor, batch2_: *C_tensor);
    func atg_addbmm_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, batch1_: *C_tensor, batch2_: *C_tensor);
    func atg_addcdiv(out__: *C_tensor, self_: *C_tensor, tensor1_: *C_tensor, tensor2_: *C_tensor);
    func atg_addcdiv_(out__: *C_tensor, self_: *C_tensor, tensor1_: *C_tensor, tensor2_: *C_tensor);
    func atg_addcdiv_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, tensor1_: *C_tensor, tensor2_: *C_tensor);
    func atg_addcmul(out__: *C_tensor, self_: *C_tensor, tensor1_: *C_tensor, tensor2_: *C_tensor);
    func atg_addcmul_(out__: *C_tensor, self_: *C_tensor, tensor1_: *C_tensor, tensor2_: *C_tensor);
    func atg_addcmul_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, tensor1_: *C_tensor, tensor2_: *C_tensor);
    func atg_addmm(out__: *C_tensor, self_: *C_tensor, mat1_: *C_tensor, mat2_: *C_tensor);
    func atg_addmm_(out__: *C_tensor, self_: *C_tensor, mat1_: *C_tensor, mat2_: *C_tensor);
    func atg_addmm_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, mat1_: *C_tensor, mat2_: *C_tensor);
    func atg_addmv(out__: *C_tensor, self_: *C_tensor, mat_: *C_tensor, vec_: *C_tensor);
    func atg_addmv_(out__: *C_tensor, self_: *C_tensor, mat_: *C_tensor, vec_: *C_tensor);
    func atg_addmv_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, mat_: *C_tensor, vec_: *C_tensor);
    func atg_addr(out__: *C_tensor, self_: *C_tensor, vec1_: *C_tensor, vec2_: *C_tensor);
    func atg_addr_(out__: *C_tensor, self_: *C_tensor, vec1_: *C_tensor, vec2_: *C_tensor);
    func atg_addr_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, vec1_: *C_tensor, vec2_: *C_tensor);
    func atg_affine_grid_generator(out__: *C_tensor, theta_: *C_tensor, size_data int64, size_len c_int, align_corners_: c_int);
    func atg_affine_grid_generator_backward(out__: *C_tensor, grad_: *C_tensor, size_data int64, size_len c_int, align_corners_: c_int);
    func atg_alias(out__: *C_tensor, self_: *C_tensor);
    func atg_align_as(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_align_tensors(tensors_data *C_tensor, tensors_len c_int) -> *C_tensor;
    func atg_all(out__: *C_tensor, self_: *C_tensor);
    func atg_all1(out__: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg_all_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg_alpha_dropout(out__: *C_tensor, input_: *C_tensor, p_: float64, train_: c_int);
    func atg_alpha_dropout_(out__: *C_tensor, self_: *C_tensor, p_: float64, train_: c_int);
    func atg_angle(out__: *C_tensor, self_: *C_tensor);
    func atg_angle_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_any(out__: *C_tensor, self_: *C_tensor);
    func atg_any1(out__: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg_any_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg_arange(out__: *C_tensor, end_: *C_scalar, options_kind c_int, options_device c_int);
    func atg_arange1(out__: *C_tensor, start_: *C_scalar, end_: *C_scalar, options_kind c_int, options_device c_int);
    func atg_arange2(out__: *C_tensor, start_: *C_scalar, end_: *C_scalar, step_: *C_scalar, options_kind c_int, options_device c_int);
    func atg_arange_out(out__: *C_tensor, out_: *C_tensor, end_: *C_scalar);
    func atg_arange_out1(out__: *C_tensor, out_: *C_tensor, start_: *C_scalar, end_: *C_scalar);
    func atg_argmax(out__: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg_argmin(out__: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg_argsort(out__: *C_tensor, self_: *C_tensor, dim_: int64, descending_: c_int);
    func atg_as_strided(out__: *C_tensor, self_: *C_tensor, size_data int64, size_len c_int, stride_data int64, stride_len c_int, storage_offset_: int64);
    func atg_as_strided_(out__: *C_tensor, self_: *C_tensor, size_data int64, size_len c_int, stride_data int64, stride_len c_int, storage_offset_: int64);
    func atg_asin(out__: *C_tensor, self_: *C_tensor);
    func atg_asin_(out__: *C_tensor, self_: *C_tensor);
    func atg_asin_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_atan(out__: *C_tensor, self_: *C_tensor);
    func atg_atan2(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_atan2_(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_atan2_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_atan_(out__: *C_tensor, self_: *C_tensor);
    func atg_atan_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_avg_pool1d(out__: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, ceil_mode_: c_int, count_include_pad_: c_int);
    func atg_avg_pool2d(out__: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, ceil_mode_: c_int, count_include_pad_: c_int, divisor_override_: int64);
    func atg_avg_pool2d_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, ceil_mode_: c_int, count_include_pad_: c_int, divisor_override_: int64);
    func atg_avg_pool2d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, ceil_mode_: c_int, count_include_pad_: c_int, divisor_override_: int64);
    func atg_avg_pool2d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, ceil_mode_: c_int, count_include_pad_: c_int, divisor_override_: int64);
    func atg_avg_pool3d(out__: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, ceil_mode_: c_int, count_include_pad_: c_int, divisor_override_: int64);
    func atg_avg_pool3d_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, ceil_mode_: c_int, count_include_pad_: c_int, divisor_override_: int64);
    func atg_avg_pool3d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, ceil_mode_: c_int, count_include_pad_: c_int, divisor_override_: int64);
    func atg_avg_pool3d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, ceil_mode_: c_int, count_include_pad_: c_int, divisor_override_: int64);
    func atg_baddbmm(out__: *C_tensor, self_: *C_tensor, batch1_: *C_tensor, batch2_: *C_tensor);
    func atg_baddbmm_(out__: *C_tensor, self_: *C_tensor, batch1_: *C_tensor, batch2_: *C_tensor);
    func atg_baddbmm_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, batch1_: *C_tensor, batch2_: *C_tensor);
    func atg_bartlett_window(out__: *C_tensor, window_length_: int64, options_kind c_int, options_device c_int);
    func atg_bartlett_window1(out__: *C_tensor, window_length_: int64, periodic_: c_int, options_kind c_int, options_device c_int);
    func atg_batch_norm(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, running_mean_: *C_tensor, running_var_: *C_tensor, training_: c_int, momentum_: float64, eps_: float64, cudnn_enabled_: c_int);
    func atg_batch_norm_backward_elemt(out__: *C_tensor, grad_out_: *C_tensor, input_: *C_tensor, mean_: *C_tensor, invstd_: *C_tensor, weight_: *C_tensor, mean_dy_: *C_tensor, mean_dy_xmu_: *C_tensor);
    func atg_batch_norm_backward_reduce(out__: *C_tensor, grad_out_: *C_tensor, input_: *C_tensor, mean_: *C_tensor, invstd_: *C_tensor, weight_: *C_tensor, input_g_: c_int, weight_g_: c_int, bias_g_: c_int);
    func atg_batch_norm_elemt(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, mean_: *C_tensor, invstd_: *C_tensor, eps_: float64);
    func atg_batch_norm_elemt_out(out__: *C_tensor, out_: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, mean_: *C_tensor, invstd_: *C_tensor, eps_: float64);
    func atg_batch_norm_gather_stats(out__: *C_tensor, input_: *C_tensor, mean_: *C_tensor, invstd_: *C_tensor, running_mean_: *C_tensor, running_var_: *C_tensor, momentum_: float64, eps_: float64, count_: int64);
    func atg_batch_norm_gather_stats_with_counts(out__: *C_tensor, input_: *C_tensor, mean_: *C_tensor, invstd_: *C_tensor, running_mean_: *C_tensor, running_var_: *C_tensor, momentum_: float64, eps_: float64, counts_data int64, counts_len c_int);
    func atg_batch_norm_stats(out__: *C_tensor, input_: *C_tensor, eps_: float64);
    func atg_batch_norm_update_stats(out__: *C_tensor, input_: *C_tensor, running_mean_: *C_tensor, running_var_: *C_tensor, momentum_: float64);
    func atg_bernoulli(out__: *C_tensor, self_: *C_tensor);
    func atg_bernoulli1(out__: *C_tensor, self_: *C_tensor, p_: float64);
    func atg_bernoulli_(out__: *C_tensor, self_: *C_tensor, p_: *C_tensor);
    func atg_bernoulli_1(out__: *C_tensor, self_: *C_tensor, p_: float64);
    func atg_bernoulli_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_bilinear(out__: *C_tensor, input1_: *C_tensor, input2_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor);
    func atg_binary_cross_entropy(out__: *C_tensor, self_: *C_tensor, target_: *C_tensor, weight_: *C_tensor, reduction_: int64);
    func atg_binary_cross_entropy_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, weight_: *C_tensor, reduction_: int64);
    func atg_binary_cross_entropy_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, weight_: *C_tensor, reduction_: int64);
    func atg_binary_cross_entropy_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, target_: *C_tensor, weight_: *C_tensor, reduction_: int64);
    func atg_binary_cross_entropy_with_logits(out__: *C_tensor, self_: *C_tensor, target_: *C_tensor, weight_: *C_tensor, pos_weight_: *C_tensor, reduction_: int64);
    func atg_binary_cross_entropy_with_logits_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, weight_: *C_tensor, pos_weight_: *C_tensor, reduction_: int64);
    func atg_bincount(out__: *C_tensor, self_: *C_tensor, weights_: *C_tensor, minlength_: int64);
    func atg_bitwise_and(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_bitwise_and1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_bitwise_and_(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_bitwise_and_1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_bitwise_and_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_bitwise_and_out1(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_bitwise_not(out__: *C_tensor, self_: *C_tensor);
    func atg_bitwise_not_(out__: *C_tensor, self_: *C_tensor);
    func atg_bitwise_not_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_bitwise_or(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_bitwise_or1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_bitwise_or_(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_bitwise_or_1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_bitwise_or_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_bitwise_or_out1(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_bitwise_xor(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_bitwise_xor1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_bitwise_xor_(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_bitwise_xor_1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_bitwise_xor_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_bitwise_xor_out1(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_blackman_window(out__: *C_tensor, window_length_: int64, options_kind c_int, options_device c_int);
    func atg_blackman_window1(out__: *C_tensor, window_length_: int64, periodic_: c_int, options_kind c_int, options_device c_int);
    func atg_bmm(out__: *C_tensor, self_: *C_tensor, mat2_: *C_tensor);
    func atg_bmm_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, mat2_: *C_tensor);
    func atg_broadcast_tensors(tensors_data *C_tensor, tensors_len c_int) -> *C_tensor;
    func atg_cartesian_prod(out__: *C_tensor, tensors_data *C_tensor, tensors_len c_int);
    func atg_cat(out__: *C_tensor, tensors_data *C_tensor, tensors_len c_int, dim_: int64);
    func atg_cat_out(out__: *C_tensor, out_: *C_tensor, tensors_data *C_tensor, tensors_len c_int, dim_: int64);
    func atg_cauchy_(out__: *C_tensor, self_: *C_tensor, median_: float64, sigma_: float64);
    func atg_cdist(out__: *C_tensor, x1_: *C_tensor, x2_: *C_tensor, p_: float64, compute_mode_: int64);
    func atg_ceil(out__: *C_tensor, self_: *C_tensor);
    func atg_ceil_(out__: *C_tensor, self_: *C_tensor);
    func atg_ceil_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_celu(out__: *C_tensor, self_: *C_tensor);
    func atg_celu_(out__: *C_tensor, self_: *C_tensor);
    func atg_chain_matmul(out__: *C_tensor, matrices_data *C_tensor, matrices_len c_int);
    func atg_cholesky(out__: *C_tensor, self_: *C_tensor, upper_: c_int);
    func atg_cholesky_inverse(out__: *C_tensor, self_: *C_tensor, upper_: c_int);
    func atg_cholesky_inverse_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, upper_: c_int);
    func atg_cholesky_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, upper_: c_int);
    func atg_cholesky_solve(out__: *C_tensor, self_: *C_tensor, input2_: *C_tensor, upper_: c_int);
    func atg_cholesky_solve_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, input2_: *C_tensor, upper_: c_int);
    func atg_chunk(self_: *C_tensor, chunks_: int64, dim_: int64) -> *C_tensor;
    func atg_clamp(out__: *C_tensor, self_: *C_tensor, min_: *C_scalar, max_: *C_scalar);
    func atg_clamp_(out__: *C_tensor, self_: *C_tensor, min_: *C_scalar, max_: *C_scalar);
    func atg_clamp_max(out__: *C_tensor, self_: *C_tensor, max_: *C_scalar);
    func atg_clamp_max_(out__: *C_tensor, self_: *C_tensor, max_: *C_scalar);
    func atg_clamp_max_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, max_: *C_scalar);
    func atg_clamp_min(out__: *C_tensor, self_: *C_tensor, min_: *C_scalar);
    func atg_clamp_min_(out__: *C_tensor, self_: *C_tensor, min_: *C_scalar);
    func atg_clamp_min_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, min_: *C_scalar);
    func atg_clamp_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, min_: *C_scalar, max_: *C_scalar);
    func atg_coalesce(out__: *C_tensor, self_: *C_tensor);
    func atg_col2im(out__: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int, kernel_size_data int64, kernel_size_len c_int, dilation_data int64, dilation_len c_int, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int);
    func atg_col2im_backward(out__: *C_tensor, grad_output_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, dilation_data int64, dilation_len c_int, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int);
    func atg_col2im_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, dilation_data int64, dilation_len c_int, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int);
    func atg_col2im_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int, kernel_size_data int64, kernel_size_len c_int, dilation_data int64, dilation_len c_int, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int);
    func atg_combinations(out__: *C_tensor, self_: *C_tensor, r_: int64, with_replacement_: c_int);
    func atg_conj(out__: *C_tensor, self_: *C_tensor);
    func atg_conj_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_constant_pad_nd(out__: *C_tensor, self_: *C_tensor, pad_data int64, pad_len c_int);
    func atg_contiguous(out__: *C_tensor, self_: *C_tensor);
    func atg_conv1d(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, groups_: int64);
    func atg_conv2d(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, groups_: int64);
    func atg_conv3d(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, groups_: int64);
    func atg_conv_tbc(out__: *C_tensor, self_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, pad_: int64);
    func atg_conv_tbc_backward(out__: *C_tensor, self_: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, pad_: int64);
    func atg_conv_transpose1d(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, output_padding_data int64, output_padding_len c_int, groups_: int64, dilation_data int64, dilation_len c_int);
    func atg_conv_transpose2d(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, output_padding_data int64, output_padding_len c_int, groups_: int64, dilation_data int64, dilation_len c_int);
    func atg_conv_transpose3d(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, output_padding_data int64, output_padding_len c_int, groups_: int64, dilation_data int64, dilation_len c_int);
    func atg_convolution(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, transposed_: c_int, output_padding_data int64, output_padding_len c_int, groups_: int64);
    func atg_convolution_overrideable(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, transposed_: c_int, output_padding_data int64, output_padding_len c_int, groups_: int64);
    func atg_copy_sparse_to_sparse_(out__: *C_tensor, self_: *C_tensor, src_: *C_tensor, non_blocking_: c_int);
    func atg_cos(out__: *C_tensor, self_: *C_tensor);
    func atg_cos_(out__: *C_tensor, self_: *C_tensor);
    func atg_cos_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_cosh(out__: *C_tensor, self_: *C_tensor);
    func atg_cosh_(out__: *C_tensor, self_: *C_tensor);
    func atg_cosh_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_cosine_embedding_loss(out__: *C_tensor, input1_: *C_tensor, input2_: *C_tensor, target_: *C_tensor, margin_: float64, reduction_: int64);
    func atg_cosine_similarity(out__: *C_tensor, x1_: *C_tensor, x2_: *C_tensor, dim_: int64, eps_: float64);
    func atg_cross(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor, dim_: int64);
    func atg_cross_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor, dim_: int64);
    func atg_ctc_loss(out__: *C_tensor, log_probs_: *C_tensor, targets_: *C_tensor, input_lengths_data int64, input_lengths_len c_int, target_lengths_data int64, target_lengths_len c_int, blank_: int64, reduction_: int64, zero_infinity_: c_int);
    func atg_ctc_loss1(out__: *C_tensor, log_probs_: *C_tensor, targets_: *C_tensor, input_lengths_: *C_tensor, target_lengths_: *C_tensor, blank_: int64, reduction_: int64, zero_infinity_: c_int);
    func atg_cudnn_affine_grid_generator(out__: *C_tensor, theta_: *C_tensor, n_: int64, C_: int64, H_: int64, W_: int64);
    func atg_cudnn_affine_grid_generator_backward(out__: *C_tensor, grad_: *C_tensor, n_: int64, C_: int64, H_: int64, W_: int64);
    func atg_cudnn_batch_norm(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, running_mean_: *C_tensor, running_var_: *C_tensor, training_: c_int, exponential_average_factor_: float64, epsilon_: float64);
    func atg_cudnn_batch_norm_backward(out__: *C_tensor, input_: *C_tensor, grad_output_: *C_tensor, weight_: *C_tensor, running_mean_: *C_tensor, running_var_: *C_tensor, save_mean_: *C_tensor, save_var_: *C_tensor, epsilon_: float64, reserveSpace_: *C_tensor);
    func atg_cudnn_convolution(out__: *C_tensor, self_: *C_tensor, weight_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int);
    func atg_cudnn_convolution1(out__: *C_tensor, self_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int);
    func atg_cudnn_convolution_backward_input(out__: *C_tensor, self_size_data int64, self_size_len c_int, grad_output_: *C_tensor, weight_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int);
    func atg_cudnn_convolution_backward_weight(out__: *C_tensor, weight_size_data int64, weight_size_len c_int, grad_output_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int);
    func atg_cudnn_convolution_transpose(out__: *C_tensor, self_: *C_tensor, weight_: *C_tensor, padding_data int64, padding_len c_int, output_padding_data int64, output_padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int);
    func atg_cudnn_convolution_transpose1(out__: *C_tensor, self_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, padding_data int64, padding_len c_int, output_padding_data int64, output_padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int);
    func atg_cudnn_convolution_transpose_backward_input(out__: *C_tensor, grad_output_: *C_tensor, weight_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int);
    func atg_cudnn_convolution_transpose_backward_weight(out__: *C_tensor, weight_size_data int64, weight_size_len c_int, grad_output_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int);
    func atg_cudnn_grid_sampler(out__: *C_tensor, self_: *C_tensor, grid_: *C_tensor);
    func atg_cudnn_grid_sampler_backward(out__: *C_tensor, self_: *C_tensor, grid_: *C_tensor, grad_output_: *C_tensor);
    func atg_cummax(out__: *C_tensor, self_: *C_tensor, dim_: int64);
    func atg_cummax_out(out__: *C_tensor, values_: *C_tensor, indices_: *C_tensor, self_: *C_tensor, dim_: int64);
    func atg_cummin(out__: *C_tensor, self_: *C_tensor, dim_: int64);
    func atg_cummin_out(out__: *C_tensor, values_: *C_tensor, indices_: *C_tensor, self_: *C_tensor, dim_: int64);
    func atg_cumprod(out__: *C_tensor, self_: *C_tensor, dim_: int64, dtype_: c_int);
    func atg_cumprod_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, dim_: int64, dtype_: c_int);
    func atg_cumsum(out__: *C_tensor, self_: *C_tensor, dim_: int64, dtype_: c_int);
    func atg_cumsum_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, dim_: int64, dtype_: c_int);
    func atg_data(out__: *C_tensor, self_: *C_tensor);
    func atg_dequantize(out__: *C_tensor, self_: *C_tensor);
    func atg_det(out__: *C_tensor, self_: *C_tensor);
    func atg_detach(out__: *C_tensor, self_: *C_tensor);
    func atg_detach_(out__: *C_tensor, self_: *C_tensor);
    func atg_diag(out__: *C_tensor, self_: *C_tensor, diagonal_: int64);
    func atg_diag_embed(out__: *C_tensor, self_: *C_tensor, offset_: int64, dim1_: int64, dim2_: int64);
    func atg_diag_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, diagonal_: int64);
    func atg_diagflat(out__: *C_tensor, self_: *C_tensor, offset_: int64);
    func atg_diagonal(out__: *C_tensor, self_: *C_tensor, offset_: int64, dim1_: int64, dim2_: int64);
    func atg_digamma(out__: *C_tensor, self_: *C_tensor);
    func atg_digamma_(out__: *C_tensor, self_: *C_tensor);
    func atg_digamma_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_dist(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_div(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_div1(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_div_(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_div_1(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_div_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_dot(out__: *C_tensor, self_: *C_tensor, tensor_: *C_tensor);
    func atg_dot_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, tensor_: *C_tensor);
    func atg_dropout(out__: *C_tensor, input_: *C_tensor, p_: float64, train_: c_int);
    func atg_dropout_(out__: *C_tensor, self_: *C_tensor, p_: float64, train_: c_int);
    func atg_eig(out__: *C_tensor, self_: *C_tensor, eigenvectors_: c_int);
    func atg_eig_out(out__: *C_tensor, e_: *C_tensor, v_: *C_tensor, self_: *C_tensor, eigenvectors_: c_int);
    func atg_einsum(out__: *C_tensor, equation_ptr int, equation_len c_int, tensors_data *C_tensor, tensors_len c_int);
    func atg_elu(out__: *C_tensor, self_: *C_tensor);
    func atg_elu_(out__: *C_tensor, self_: *C_tensor);
    func atg_elu_backward(out__: *C_tensor, grad_output_: *C_tensor, alpha_: *C_scalar, scale_: *C_scalar, input_scale_: *C_scalar, output_: *C_tensor);
    func atg_elu_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, alpha_: *C_scalar, scale_: *C_scalar, input_scale_: *C_scalar, output_: *C_tensor);
    func atg_elu_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_embedding(out__: *C_tensor, weight_: *C_tensor, indices_: *C_tensor, padding_idx_: int64, scale_grad_by_freq_: c_int, sparse_: c_int);
    func atg_embedding_backward(out__: *C_tensor, grad_: *C_tensor, indices_: *C_tensor, num_weights_: int64, padding_idx_: int64, scale_grad_by_freq_: c_int, sparse_: c_int);
    func atg_embedding_bag(out__: *C_tensor, weight_: *C_tensor, indices_: *C_tensor, offsets_: *C_tensor, scale_grad_by_freq_: c_int, mode_: int64, sparse_: c_int, per_sample_weights_: *C_tensor, include_last_offset_: c_int);
    func atg_embedding_dense_backward(out__: *C_tensor, grad_output_: *C_tensor, indices_: *C_tensor, num_weights_: int64, padding_idx_: int64, scale_grad_by_freq_: c_int);
    func atg_embedding_renorm_(out__: *C_tensor, self_: *C_tensor, indices_: *C_tensor, max_norm_: float64, norm_type_: float64);
    func atg_embedding_sparse_backward(out__: *C_tensor, grad_: *C_tensor, indices_: *C_tensor, num_weights_: int64, padding_idx_: int64, scale_grad_by_freq_: c_int);
    func atg_empty(out__: *C_tensor, size_data int64, size_len c_int, options_kind c_int, options_device c_int);
    func atg_empty_like(out__: *C_tensor, self_: *C_tensor);
    func atg_empty_out(out__: *C_tensor, out_: *C_tensor, size_data int64, size_len c_int);
    func atg_empty_strided(out__: *C_tensor, size_data int64, size_len c_int, stride_data int64, stride_len c_int, options_kind c_int, options_device c_int);
    func atg_eq(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_eq1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_eq_(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_eq_1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_eq_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_eq_out1(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_erf(out__: *C_tensor, self_: *C_tensor);
    func atg_erf_(out__: *C_tensor, self_: *C_tensor);
    func atg_erf_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_erfc(out__: *C_tensor, self_: *C_tensor);
    func atg_erfc_(out__: *C_tensor, self_: *C_tensor);
    func atg_erfc_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_erfinv(out__: *C_tensor, self_: *C_tensor);
    func atg_erfinv_(out__: *C_tensor, self_: *C_tensor);
    func atg_erfinv_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_exp(out__: *C_tensor, self_: *C_tensor);
    func atg_exp_(out__: *C_tensor, self_: *C_tensor);
    func atg_exp_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_expand(out__: *C_tensor, self_: *C_tensor, size_data int64, size_len c_int, implicit_: c_int);
    func atg_expand_as(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_expm1(out__: *C_tensor, self_: *C_tensor);
    func atg_expm1_(out__: *C_tensor, self_: *C_tensor);
    func atg_expm1_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_exponential_(out__: *C_tensor, self_: *C_tensor, lambd_: float64);
    func atg_eye(out__: *C_tensor, n_: int64, options_kind c_int, options_device c_int);
    func atg_eye1(out__: *C_tensor, n_: int64, m_: int64, options_kind c_int, options_device c_int);
    func atg_eye_out(out__: *C_tensor, out_: *C_tensor, n_: int64);
    func atg_eye_out1(out__: *C_tensor, out_: *C_tensor, n_: int64, m_: int64);
    func atg_fake_quantize_per_channel_affine(out__: *C_tensor, self_: *C_tensor, scale_: *C_tensor, zero_point_: *C_tensor, axis_: int64, quant_min_: int64, quant_max_: int64);
    func atg_fake_quantize_per_channel_affine_backward(out__: *C_tensor, grad_: *C_tensor, self_: *C_tensor, scale_: *C_tensor, zero_point_: *C_tensor, axis_: int64, quant_min_: int64, quant_max_: int64);
    func atg_fake_quantize_per_tensor_affine(out__: *C_tensor, self_: *C_tensor, scale_: float64, zero_point_: int64, quant_min_: int64, quant_max_: int64);
    func atg_fake_quantize_per_tensor_affine_backward(out__: *C_tensor, grad_: *C_tensor, self_: *C_tensor, scale_: float64, zero_point_: int64, quant_min_: int64, quant_max_: int64);
    func atg_fbgemm_linear_fp16_weight(out__: *C_tensor, input_: *C_tensor, packed_weight_: *C_tensor, bias_: *C_tensor);
    func atg_fbgemm_linear_fp16_weight_fp32_activation(out__: *C_tensor, input_: *C_tensor, packed_weight_: *C_tensor, bias_: *C_tensor);
    func atg_fbgemm_linear_int8_weight(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, packed_: *C_tensor, col_offsets_: *C_tensor, weight_scale_: *C_scalar, weight_zero_point_: *C_scalar, bias_: *C_tensor);
    func atg_fbgemm_linear_int8_weight_fp32_activation(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, packed_: *C_tensor, col_offsets_: *C_tensor, weight_scale_: *C_scalar, weight_zero_point_: *C_scalar, bias_: *C_tensor);
    func atg_fbgemm_pack_gemm_matrix_fp16(out__: *C_tensor, input_: *C_tensor);
    func atg_fbgemm_pack_quantized_matrix(out__: *C_tensor, input_: *C_tensor);
    func atg_fbgemm_pack_quantized_matrix1(out__: *C_tensor, input_: *C_tensor, K_: int64, n_: int64);
    func atg_feature_alpha_dropout(out__: *C_tensor, input_: *C_tensor, p_: float64, train_: c_int);
    func atg_feature_alpha_dropout_(out__: *C_tensor, self_: *C_tensor, p_: float64, train_: c_int);
    func atg_feature_dropout(out__: *C_tensor, input_: *C_tensor, p_: float64, train_: c_int);
    func atg_feature_dropout_(out__: *C_tensor, self_: *C_tensor, p_: float64, train_: c_int);
    func atg_fft(out__: *C_tensor, self_: *C_tensor, signal_ndim_: int64, normalized_: c_int);
    func atg_fill_(out__: *C_tensor, self_: *C_tensor, value_: *C_scalar);
    func atg_fill_1(out__: *C_tensor, self_: *C_tensor, value_: *C_tensor);
    func atg_fill_diagonal_(out__: *C_tensor, self_: *C_tensor, fill_value_: *C_scalar, wrap_: c_int);
    func atg_flatten(out__: *C_tensor, self_: *C_tensor, start_dim_: int64, end_dim_: int64);
    func atg_flip(out__: *C_tensor, self_: *C_tensor, dims_data int64, dims_len c_int);
    func atg_floor(out__: *C_tensor, self_: *C_tensor);
    func atg_floor_(out__: *C_tensor, self_: *C_tensor);
    func atg_floor_divide(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_floor_divide1(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_floor_divide_(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_floor_divide_1(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_floor_divide_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_floor_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_fmod(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_fmod1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_fmod_(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_fmod_1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_fmod_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_fmod_out1(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_frac(out__: *C_tensor, self_: *C_tensor);
    func atg_frac_(out__: *C_tensor, self_: *C_tensor);
    func atg_frac_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_fractional_max_pool2d(out__: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, output_size_data int64, output_size_len c_int, random_samples_: *C_tensor);
    func atg_fractional_max_pool2d_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, output_size_data int64, output_size_len c_int, indices_: *C_tensor);
    func atg_fractional_max_pool2d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, output_size_data int64, output_size_len c_int, indices_: *C_tensor);
    func atg_fractional_max_pool2d_out(out__: *C_tensor, output_: *C_tensor, indices_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, output_size_data int64, output_size_len c_int, random_samples_: *C_tensor);
    func atg_fractional_max_pool3d(out__: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, output_size_data int64, output_size_len c_int, random_samples_: *C_tensor);
    func atg_fractional_max_pool3d_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, output_size_data int64, output_size_len c_int, indices_: *C_tensor);
    func atg_fractional_max_pool3d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, output_size_data int64, output_size_len c_int, indices_: *C_tensor);
    func atg_fractional_max_pool3d_out(out__: *C_tensor, output_: *C_tensor, indices_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, output_size_data int64, output_size_len c_int, random_samples_: *C_tensor);
    func atg_frobenius_norm(out__: *C_tensor, self_: *C_tensor);
    func atg_frobenius_norm1(out__: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, keepdim_: c_int);
    func atg_frobenius_norm_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, keepdim_: c_int);
    func atg_from_file(out__: *C_tensor, filename_ptr int, filename_len c_int, shared_: c_int, size_: int64, options_kind c_int, options_device c_int);
    func atg_full(out__: *C_tensor, size_data int64, size_len c_int, fill_value_: *C_scalar, options_kind c_int, options_device c_int);
    func atg_full_like(out__: *C_tensor, self_: *C_tensor, fill_value_: *C_scalar);
    func atg_full_out(out__: *C_tensor, out_: *C_tensor, size_data int64, size_len c_int, fill_value_: *C_scalar);
    func atg_gather(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, sparse_grad_: c_int);
    func atg_gather_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, sparse_grad_: c_int);
    func atg_ge(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_ge1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_ge_(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_ge_1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_ge_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_ge_out1(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_gelu(out__: *C_tensor, self_: *C_tensor);
    func atg_gelu_backward(out__: *C_tensor, grad_: *C_tensor, self_: *C_tensor);
    func atg_geometric_(out__: *C_tensor, self_: *C_tensor, p_: float64);
    func atg_geqrf(out__: *C_tensor, self_: *C_tensor);
    func atg_geqrf_out(out__: *C_tensor, a_: *C_tensor, tau_: *C_tensor, self_: *C_tensor);
    func atg_ger(out__: *C_tensor, self_: *C_tensor, vec2_: *C_tensor);
    func atg_ger_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, vec2_: *C_tensor);
    func atg_glu(out__: *C_tensor, self_: *C_tensor, dim_: int64);
    func atg_glu_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, dim_: int64);
    func atg_glu_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, dim_: int64);
    func atg_glu_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, dim_: int64);
    func atg_grad(out__: *C_tensor, self_: *C_tensor);
    func atg_grid_sampler(out__: *C_tensor, input_: *C_tensor, grid_: *C_tensor, interpolation_mode_: int64, padding_mode_: int64, align_corners_: c_int);
    func atg_grid_sampler_2d(out__: *C_tensor, input_: *C_tensor, grid_: *C_tensor, interpolation_mode_: int64, padding_mode_: int64, align_corners_: c_int);
    func atg_grid_sampler_2d_backward(out__: *C_tensor, grad_output_: *C_tensor, input_: *C_tensor, grid_: *C_tensor, interpolation_mode_: int64, padding_mode_: int64, align_corners_: c_int);
    func atg_grid_sampler_3d(out__: *C_tensor, input_: *C_tensor, grid_: *C_tensor, interpolation_mode_: int64, padding_mode_: int64, align_corners_: c_int);
    func atg_grid_sampler_3d_backward(out__: *C_tensor, grad_output_: *C_tensor, input_: *C_tensor, grid_: *C_tensor, interpolation_mode_: int64, padding_mode_: int64, align_corners_: c_int);
    func atg_group_norm(out__: *C_tensor, input_: *C_tensor, num_groups_: int64, weight_: *C_tensor, bias_: *C_tensor, eps_: float64, cudnn_enabled_: c_int);
    func atg_gru(out__: *C_tensor, input_: *C_tensor, hx_: *C_tensor, params_data *C_tensor, params_len c_int, has_biases_: c_int, num_layers_: int64, dropout_: float64, train_: c_int, bidirectional_: c_int, batch_first_: c_int);
    func atg_gru1(out__: *C_tensor, data_: *C_tensor, batch_sizes_: *C_tensor, hx_: *C_tensor, params_data *C_tensor, params_len c_int, has_biases_: c_int, num_layers_: int64, dropout_: float64, train_: c_int, bidirectional_: c_int);
    func atg_gru_cell(out__: *C_tensor, input_: *C_tensor, hx_: *C_tensor, w_ih_: *C_tensor, w_hh_: *C_tensor, b_ih_: *C_tensor, b_hh_: *C_tensor);
    func atg_gt(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_gt1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_gt_(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_gt_1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_gt_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_gt_out1(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_hamming_window(out__: *C_tensor, window_length_: int64, options_kind c_int, options_device c_int);
    func atg_hamming_window1(out__: *C_tensor, window_length_: int64, periodic_: c_int, options_kind c_int, options_device c_int);
    func atg_hamming_window2(out__: *C_tensor, window_length_: int64, periodic_: c_int, alpha_: float64, options_kind c_int, options_device c_int);
    func atg_hamming_window3(out__: *C_tensor, window_length_: int64, periodic_: c_int, alpha_: float64, beta_: float64, options_kind c_int, options_device c_int);
    func atg_hann_window(out__: *C_tensor, window_length_: int64, options_kind c_int, options_device c_int);
    func atg_hann_window1(out__: *C_tensor, window_length_: int64, periodic_: c_int, options_kind c_int, options_device c_int);
    func atg_hardshrink(out__: *C_tensor, self_: *C_tensor);
    func atg_hardshrink_backward(out__: *C_tensor, grad_out_: *C_tensor, self_: *C_tensor, lambd_: *C_scalar);
    func atg_hardsigmoid(out__: *C_tensor, self_: *C_tensor);
    func atg_hardsigmoid_(out__: *C_tensor, self_: *C_tensor);
    func atg_hardsigmoid_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor);
    func atg_hardsigmoid_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_hardtanh(out__: *C_tensor, self_: *C_tensor);
    func atg_hardtanh_(out__: *C_tensor, self_: *C_tensor);
    func atg_hardtanh_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, min_val_: *C_scalar, max_val_: *C_scalar);
    func atg_hardtanh_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, min_val_: *C_scalar, max_val_: *C_scalar);
    func atg_hardtanh_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_hinge_embedding_loss(out__: *C_tensor, self_: *C_tensor, target_: *C_tensor, margin_: float64, reduction_: int64);
    func atg_histc(out__: *C_tensor, self_: *C_tensor, bins_: int64);
    func atg_histc_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, bins_: int64);
    func atg_hspmm(out__: *C_tensor, mat1_: *C_tensor, mat2_: *C_tensor);
    func atg_hspmm_out(out__: *C_tensor, out_: *C_tensor, mat1_: *C_tensor, mat2_: *C_tensor);
    func atg_ifft(out__: *C_tensor, self_: *C_tensor, signal_ndim_: int64, normalized_: c_int);
    func atg_im2col(out__: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, dilation_data int64, dilation_len c_int, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int);
    func atg_im2col_backward(out__: *C_tensor, grad_output_: *C_tensor, input_size_data int64, input_size_len c_int, kernel_size_data int64, kernel_size_len c_int, dilation_data int64, dilation_len c_int, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int);
    func atg_im2col_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, input_size_data int64, input_size_len c_int, kernel_size_data int64, kernel_size_len c_int, dilation_data int64, dilation_len c_int, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int);
    func atg_im2col_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, dilation_data int64, dilation_len c_int, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int);
    func atg_imag(out__: *C_tensor, self_: *C_tensor);
    func atg_index(out__: *C_tensor, self_: *C_tensor, indices_data *C_tensor, indices_len c_int);
    func atg_index_add(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, source_: *C_tensor);
    func atg_index_add_(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, source_: *C_tensor);
    func atg_index_copy(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, source_: *C_tensor);
    func atg_index_copy_(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, source_: *C_tensor);
    func atg_index_fill(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, value_: *C_scalar);
    func atg_index_fill1(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, value_: *C_tensor);
    func atg_index_fill_(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, value_: *C_scalar);
    func atg_index_fill_1(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, value_: *C_tensor);
    func atg_index_put(out__: *C_tensor, self_: *C_tensor, indices_data *C_tensor, indices_len c_int, values_: *C_tensor, accumulate_: c_int);
    func atg_index_put_(out__: *C_tensor, self_: *C_tensor, indices_data *C_tensor, indices_len c_int, values_: *C_tensor, accumulate_: c_int);
    func atg_index_select(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor);
    func atg_index_select_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor);
    func atg_indices(out__: *C_tensor, self_: *C_tensor);
    func atg_instance_norm(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, running_mean_: *C_tensor, running_var_: *C_tensor, use_input_stats_: c_int, momentum_: float64, eps_: float64, cudnn_enabled_: c_int);
    func atg_int_repr(out__: *C_tensor, self_: *C_tensor);
    func atg_inverse(out__: *C_tensor, self_: *C_tensor);
    func atg_inverse_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_irfft(out__: *C_tensor, self_: *C_tensor, signal_ndim_: int64, normalized_: c_int, onesided_: c_int, signal_sizes_data int64, signal_sizes_len c_int);
    func atg_isclose(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor, rtol_: float64, atol_: float64, equal_nan_: c_int);
    func atg_isfinite(out__: *C_tensor, self_: *C_tensor);
    func atg_isinf(out__: *C_tensor, self_: *C_tensor);
    func atg_isnan(out__: *C_tensor, self_: *C_tensor);
    func atg_kl_div(out__: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_kl_div_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_kthvalue(out__: *C_tensor, self_: *C_tensor, k_: int64, dim_: int64, keepdim_: c_int);
    func atg_kthvalue_out(out__: *C_tensor, values_: *C_tensor, indices_: *C_tensor, self_: *C_tensor, k_: int64, dim_: int64, keepdim_: c_int);
    func atg_l1_loss(out__: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_l1_loss_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_l1_loss_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_l1_loss_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_layer_norm(out__: *C_tensor, input_: *C_tensor, normalized_shape_data int64, normalized_shape_len c_int, weight_: *C_tensor, bias_: *C_tensor, eps_: float64, cudnn_enable_: c_int);
    func atg_le(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_le1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_le_(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_le_1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_le_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_le_out1(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_leaky_relu(out__: *C_tensor, self_: *C_tensor);
    func atg_leaky_relu_(out__: *C_tensor, self_: *C_tensor);
    func atg_leaky_relu_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, negative_slope_: *C_scalar, self_is_result_: c_int);
    func atg_leaky_relu_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_lerp(out__: *C_tensor, self_: *C_tensor, end_: *C_tensor, weight_: *C_scalar);
    func atg_lerp1(out__: *C_tensor, self_: *C_tensor, end_: *C_tensor, weight_: *C_tensor);
    func atg_lerp_(out__: *C_tensor, self_: *C_tensor, end_: *C_tensor, weight_: *C_scalar);
    func atg_lerp_1(out__: *C_tensor, self_: *C_tensor, end_: *C_tensor, weight_: *C_tensor);
    func atg_lerp_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, end_: *C_tensor, weight_: *C_scalar);
    func atg_lerp_out1(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, end_: *C_tensor, weight_: *C_tensor);
    func atg_lgamma(out__: *C_tensor, self_: *C_tensor);
    func atg_lgamma_(out__: *C_tensor, self_: *C_tensor);
    func atg_lgamma_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_linear(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor);
    func atg_linspace(out__: *C_tensor, start_: *C_scalar, end_: *C_scalar, steps_: int64, options_kind c_int, options_device c_int);
    func atg_linspace_out(out__: *C_tensor, out_: *C_tensor, start_: *C_scalar, end_: *C_scalar, steps_: int64);
    func atg_log(out__: *C_tensor, self_: *C_tensor);
    func atg_log10(out__: *C_tensor, self_: *C_tensor);
    func atg_log10_(out__: *C_tensor, self_: *C_tensor);
    func atg_log10_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_log1p(out__: *C_tensor, self_: *C_tensor);
    func atg_log1p_(out__: *C_tensor, self_: *C_tensor);
    func atg_log1p_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_log2(out__: *C_tensor, self_: *C_tensor);
    func atg_log2_(out__: *C_tensor, self_: *C_tensor);
    func atg_log2_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_log_(out__: *C_tensor, self_: *C_tensor);
    func atg_log_normal_(out__: *C_tensor, self_: *C_tensor, mean_: float64, std_: float64);
    func atg_log_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_log_sigmoid(out__: *C_tensor, self_: *C_tensor);
    func atg_log_sigmoid_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, buffer_: *C_tensor);
    func atg_log_sigmoid_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, buffer_: *C_tensor);
    func atg_log_sigmoid_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_log_softmax(out__: *C_tensor, self_: *C_tensor, dim_: int64, dtype_: c_int);
    func atg_logdet(out__: *C_tensor, self_: *C_tensor);
    func atg_logical_and(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_logical_and_(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_logical_and_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_logical_not(out__: *C_tensor, self_: *C_tensor);
    func atg_logical_not_(out__: *C_tensor, self_: *C_tensor);
    func atg_logical_not_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_logical_or(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_logical_or_(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_logical_or_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_logical_xor(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_logical_xor_(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_logical_xor_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_logspace(out__: *C_tensor, start_: *C_scalar, end_: *C_scalar, steps_: int64, base_: float64, options_kind c_int, options_device c_int);
    func atg_logspace_out(out__: *C_tensor, out_: *C_tensor, start_: *C_scalar, end_: *C_scalar, steps_: int64, base_: float64);
    func atg_logsumexp(out__: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, keepdim_: c_int);
    func atg_logsumexp_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, keepdim_: c_int);
    func atg_lstm(out__: *C_tensor, input_: *C_tensor, hx_data *C_tensor, hx_len c_int, params_data *C_tensor, params_len c_int, has_biases_: c_int, num_layers_: int64, dropout_: float64, train_: c_int, bidirectional_: c_int, batch_first_: c_int);
    func atg_lstm1(out__: *C_tensor, data_: *C_tensor, batch_sizes_: *C_tensor, hx_data *C_tensor, hx_len c_int, params_data *C_tensor, params_len c_int, has_biases_: c_int, num_layers_: int64, dropout_: float64, train_: c_int, bidirectional_: c_int);
    func atg_lstm_cell(out__: *C_tensor, input_: *C_tensor, hx_data *C_tensor, hx_len c_int, w_ih_: *C_tensor, w_hh_: *C_tensor, b_ih_: *C_tensor, b_hh_: *C_tensor);
    func atg_lstsq(out__: *C_tensor, self_: *C_tensor, A_: *C_tensor);
    func atg_lstsq_out(out__: *C_tensor, X_: *C_tensor, qr_: *C_tensor, self_: *C_tensor, A_: *C_tensor);
    func atg_lt(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_lt1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_lt_(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_lt_1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_lt_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_lt_out1(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_lu_solve(out__: *C_tensor, self_: *C_tensor, LU_data_: *C_tensor, LU_pivots_: *C_tensor);
    func atg_lu_solve_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, LU_data_: *C_tensor, LU_pivots_: *C_tensor);
    func atg_margin_ranking_loss(out__: *C_tensor, input1_: *C_tensor, input2_: *C_tensor, target_: *C_tensor, margin_: float64, reduction_: int64);
    func atg_masked_fill(out__: *C_tensor, self_: *C_tensor, mask_: *C_tensor, value_: *C_scalar);
    func atg_masked_fill1(out__: *C_tensor, self_: *C_tensor, mask_: *C_tensor, value_: *C_tensor);
    func atg_masked_fill_(out__: *C_tensor, self_: *C_tensor, mask_: *C_tensor, value_: *C_scalar);
    func atg_masked_fill_1(out__: *C_tensor, self_: *C_tensor, mask_: *C_tensor, value_: *C_tensor);
    func atg_masked_scatter(out__: *C_tensor, self_: *C_tensor, mask_: *C_tensor, source_: *C_tensor);
    func atg_masked_scatter_(out__: *C_tensor, self_: *C_tensor, mask_: *C_tensor, source_: *C_tensor);
    func atg_masked_select(out__: *C_tensor, self_: *C_tensor, mask_: *C_tensor);
    func atg_masked_select_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, mask_: *C_tensor);
    func atg_matmul(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_matmul_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_matrix_power(out__: *C_tensor, self_: *C_tensor, n_: int64);
    func atg_matrix_rank(out__: *C_tensor, self_: *C_tensor, symmetric_: c_int);
    func atg_matrix_rank1(out__: *C_tensor, self_: *C_tensor, tol_: float64, symmetric_: c_int);
    func atg_max(out__: *C_tensor, self_: *C_tensor);
    func atg_max1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_max2(out__: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg_max_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_max_out1(out__: *C_tensor, max_: *C_tensor, max_values_: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg_max_pool1d(out__: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, ceil_mode_: c_int);
    func atg_max_pool1d_with_indices(out__: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, ceil_mode_: c_int);
    func atg_max_pool2d(out__: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, ceil_mode_: c_int);
    func atg_max_pool2d_with_indices(out__: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, ceil_mode_: c_int);
    func atg_max_pool2d_with_indices_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, ceil_mode_: c_int, indices_: *C_tensor);
    func atg_max_pool2d_with_indices_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, ceil_mode_: c_int, indices_: *C_tensor);
    func atg_max_pool2d_with_indices_out(out__: *C_tensor, out_: *C_tensor, indices_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, ceil_mode_: c_int);
    func atg_max_pool3d(out__: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, ceil_mode_: c_int);
    func atg_max_pool3d_with_indices(out__: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, ceil_mode_: c_int);
    func atg_max_pool3d_with_indices_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, ceil_mode_: c_int, indices_: *C_tensor);
    func atg_max_pool3d_with_indices_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, ceil_mode_: c_int, indices_: *C_tensor);
    func atg_max_pool3d_with_indices_out(out__: *C_tensor, out_: *C_tensor, indices_: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, ceil_mode_: c_int);
    func atg_max_unpool2d(out__: *C_tensor, self_: *C_tensor, indices_: *C_tensor, output_size_data int64, output_size_len c_int);
    func atg_max_unpool2d_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, indices_: *C_tensor, output_size_data int64, output_size_len c_int);
    func atg_max_unpool2d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, indices_: *C_tensor, output_size_data int64, output_size_len c_int);
    func atg_max_unpool2d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, indices_: *C_tensor, output_size_data int64, output_size_len c_int);
    func atg_max_unpool3d(out__: *C_tensor, self_: *C_tensor, indices_: *C_tensor, output_size_data int64, output_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int);
    func atg_max_unpool3d_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, indices_: *C_tensor, output_size_data int64, output_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int);
    func atg_max_unpool3d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, indices_: *C_tensor, output_size_data int64, output_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int);
    func atg_max_unpool3d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, indices_: *C_tensor, output_size_data int64, output_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int);
    func atg_max_values(out__: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, keepdim_: c_int);
    func atg_mean(out__: *C_tensor, self_: *C_tensor, dtype_: c_int);
    func atg_mean1(out__: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, keepdim_: c_int, dtype_: c_int);
    func atg_mean_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, keepdim_: c_int, dtype_: c_int);
    func atg_median(out__: *C_tensor, self_: *C_tensor);
    func atg_median1(out__: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg_median_out(out__: *C_tensor, values_: *C_tensor, indices_: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg_meshgrid(tensors_data *C_tensor, tensors_len c_int) -> *C_tensor;
    func atg_min(out__: *C_tensor, self_: *C_tensor);
    func atg_min1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_min2(out__: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg_min_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_min_out1(out__: *C_tensor, min_: *C_tensor, min_indices_: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg_min_values(out__: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, keepdim_: c_int);
    func atg_miopen_batch_norm(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, running_mean_: *C_tensor, running_var_: *C_tensor, training_: c_int, exponential_average_factor_: float64, epsilon_: float64);
    func atg_miopen_batch_norm_backward(out__: *C_tensor, input_: *C_tensor, grad_output_: *C_tensor, weight_: *C_tensor, running_mean_: *C_tensor, running_var_: *C_tensor, save_mean_: *C_tensor, save_var_: *C_tensor, epsilon_: float64);
    func atg_miopen_convolution(out__: *C_tensor, self_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int);
    func atg_miopen_convolution_backward_bias(out__: *C_tensor, grad_output_: *C_tensor);
    func atg_miopen_convolution_backward_input(out__: *C_tensor, self_size_data int64, self_size_len c_int, grad_output_: *C_tensor, weight_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int);
    func atg_miopen_convolution_backward_weight(out__: *C_tensor, weight_size_data int64, weight_size_len c_int, grad_output_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int);
    func atg_miopen_convolution_transpose(out__: *C_tensor, self_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, padding_data int64, padding_len c_int, output_padding_data int64, output_padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int);
    func atg_miopen_convolution_transpose_backward_input(out__: *C_tensor, grad_output_: *C_tensor, weight_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int);
    func atg_miopen_convolution_transpose_backward_weight(out__: *C_tensor, weight_size_data int64, weight_size_len c_int, grad_output_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int);
    func atg_miopen_depthwise_convolution(out__: *C_tensor, self_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int);
    func atg_miopen_depthwise_convolution_backward_input(out__: *C_tensor, self_size_data int64, self_size_len c_int, grad_output_: *C_tensor, weight_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int);
    func atg_miopen_depthwise_convolution_backward_weight(out__: *C_tensor, weight_size_data int64, weight_size_len c_int, grad_output_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, benchmark_: c_int, deterministic_: c_int);
    func atg_miopen_rnn(out__: *C_tensor, input_: *C_tensor, weight_data *C_tensor, weight_len c_int, weight_stride0_: int64, hx_: *C_tensor, cx_: *C_tensor, mode_: int64, hidden_size_: int64, num_layers_: int64, batch_first_: c_int, dropout_: float64, train_: c_int, bidirectional_: c_int, batch_sizes_data int64, batch_sizes_len c_int, dropout_state_: *C_tensor);
    func atg_mkldnn_adaptive_avg_pool2d(out__: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int);
    func atg_mkldnn_convolution(out__: *C_tensor, self_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64);
    func atg_mkldnn_convolution_backward_input(out__: *C_tensor, self_size_data int64, self_size_len c_int, grad_output_: *C_tensor, weight_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, bias_defined_: c_int);
    func atg_mkldnn_convolution_backward_weights(out__: *C_tensor, weight_size_data int64, weight_size_len c_int, grad_output_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64, bias_defined_: c_int);
    func atg_mkldnn_linear(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor);
    func atg_mkldnn_max_pool2d(out__: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, ceil_mode_: c_int);
    func atg_mkldnn_reorder_conv2d_weight(out__: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int, stride_data int64, stride_len c_int, dilation_data int64, dilation_len c_int, groups_: int64);
    func atg_mm(out__: *C_tensor, self_: *C_tensor, mat2_: *C_tensor);
    func atg_mm_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, mat2_: *C_tensor);
    func atg_mode(out__: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg_mode_out(out__: *C_tensor, values_: *C_tensor, indices_: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int);
    func atg_mse_loss(out__: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_mse_loss_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_mse_loss_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_mse_loss_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_mul(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_mul1(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_mul_(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_mul_1(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_mul_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_multi_margin_loss_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, p_: *C_scalar, margin_: *C_scalar, weight_: *C_tensor, reduction_: int64);
    func atg_multi_margin_loss_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, p_: *C_scalar, margin_: *C_scalar, weight_: *C_tensor, reduction_: int64);
    func atg_multilabel_margin_loss(out__: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_multilabel_margin_loss_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64, is_target_: *C_tensor);
    func atg_multilabel_margin_loss_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64, is_target_: *C_tensor);
    func atg_multilabel_margin_loss_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_multinomial(out__: *C_tensor, self_: *C_tensor, num_samples_: int64, replacement_: c_int);
    func atg_multinomial_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, num_samples_: int64, replacement_: c_int);
    func atg_mv(out__: *C_tensor, self_: *C_tensor, vec_: *C_tensor);
    func atg_mv_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, vec_: *C_tensor);
    func atg_mvlgamma(out__: *C_tensor, self_: *C_tensor, p_: int64);
    func atg_mvlgamma_(out__: *C_tensor, self_: *C_tensor, p_: int64);
    func atg_narrow(out__: *C_tensor, self_: *C_tensor, dim_: int64, start_: int64, length_: int64);
    func atg_narrow1(out__: *C_tensor, self_: *C_tensor, dim_: int64, start_: *C_tensor, length_: int64);
    func atg_narrow_copy(out__: *C_tensor, self_: *C_tensor, dim_: int64, start_: int64, length_: int64);
    func atg_native_batch_norm(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, running_mean_: *C_tensor, running_var_: *C_tensor, training_: c_int, momentum_: float64, eps_: float64);
    func atg_native_batch_norm_out(out__: *C_tensor, out_: *C_tensor, save_mean_: *C_tensor, save_invstd_: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, running_mean_: *C_tensor, running_var_: *C_tensor, training_: c_int, momentum_: float64, eps_: float64);
    func atg_native_layer_norm(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, M_: int64, n_: int64, eps_: float64);
    func atg_native_norm(out__: *C_tensor, self_: *C_tensor);
    func atg_ne(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_ne1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_ne_(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_ne_1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_ne_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_ne_out1(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_neg(out__: *C_tensor, self_: *C_tensor);
    func atg_neg_(out__: *C_tensor, self_: *C_tensor);
    func atg_neg_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_new_empty(out__: *C_tensor, self_: *C_tensor, size_data int64, size_len c_int, options_kind c_int, options_device c_int);
    func atg_new_full(out__: *C_tensor, self_: *C_tensor, size_data int64, size_len c_int, fill_value_: *C_scalar, options_kind c_int, options_device c_int);
    func atg_new_zeros(out__: *C_tensor, self_: *C_tensor, size_data int64, size_len c_int, options_kind c_int, options_device c_int);
    func atg_nll_loss(out__: *C_tensor, self_: *C_tensor, target_: *C_tensor, weight_: *C_tensor, reduction_: int64, ignore_index_: int64);
    func atg_nll_loss2d(out__: *C_tensor, self_: *C_tensor, target_: *C_tensor, weight_: *C_tensor, reduction_: int64, ignore_index_: int64);
    func atg_nll_loss2d_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, weight_: *C_tensor, reduction_: int64, ignore_index_: int64, total_weight_: *C_tensor);
    func atg_nll_loss2d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, weight_: *C_tensor, reduction_: int64, ignore_index_: int64, total_weight_: *C_tensor);
    func atg_nll_loss2d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, target_: *C_tensor, weight_: *C_tensor, reduction_: int64, ignore_index_: int64);
    func atg_nll_loss_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, weight_: *C_tensor, reduction_: int64, ignore_index_: int64, total_weight_: *C_tensor);
    func atg_nll_loss_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, weight_: *C_tensor, reduction_: int64, ignore_index_: int64, total_weight_: *C_tensor);
    func atg_nll_loss_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, target_: *C_tensor, weight_: *C_tensor, reduction_: int64, ignore_index_: int64);
    func atg_nonzero(out__: *C_tensor, self_: *C_tensor);
    func atg_nonzero_numpy(self_: *C_tensor) -> *C_tensor;
    func atg_nonzero_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_norm(out__: *C_tensor, self_: *C_tensor);
    func atg_norm1(out__: *C_tensor, self_: *C_tensor, p_: *C_scalar, dtype_: c_int);
    func atg_norm2(out__: *C_tensor, self_: *C_tensor, p_: *C_scalar, dim_data int64, dim_len c_int, keepdim_: c_int);
    func atg_norm3(out__: *C_tensor, self_: *C_tensor, p_: *C_scalar, dim_data int64, dim_len c_int, keepdim_: c_int, dtype_: c_int);
    func atg_norm_except_dim(out__: *C_tensor, v_: *C_tensor, pow_: int64, dim_: int64);
    func atg_norm_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, p_: *C_scalar, dim_data int64, dim_len c_int, keepdim_: c_int);
    func atg_norm_out1(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, p_: *C_scalar, dim_data int64, dim_len c_int, keepdim_: c_int, dtype_: c_int);
    func atg_normal_(out__: *C_tensor, self_: *C_tensor, mean_: float64, std_: float64);
    func atg_normal_out(out__: *C_tensor, out_: *C_tensor, mean_: *C_tensor, std_: float64);
    func atg_normal_out1(out__: *C_tensor, out_: *C_tensor, mean_: float64, std_: *C_tensor);
    func atg_normal_out2(out__: *C_tensor, out_: *C_tensor, mean_: *C_tensor, std_: *C_tensor);
    func atg_normal_out3(out__: *C_tensor, out_: *C_tensor, mean_: float64, std_: float64, size_data int64, size_len c_int);
    func atg_nuclear_norm(out__: *C_tensor, self_: *C_tensor, keepdim_: c_int);
    func atg_nuclear_norm1(out__: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, keepdim_: c_int);
    func atg_nuclear_norm_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, keepdim_: c_int);
    func atg_nuclear_norm_out1(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, keepdim_: c_int);
    func atg_numpy_t(out__: *C_tensor, self_: *C_tensor);
    func atg_one_hot(out__: *C_tensor, self_: *C_tensor, num_classes_: int64);
    func atg_ones(out__: *C_tensor, size_data int64, size_len c_int, options_kind c_int, options_device c_int);
    func atg_ones_like(out__: *C_tensor, self_: *C_tensor);
    func atg_ones_out(out__: *C_tensor, out_: *C_tensor, size_data int64, size_len c_int);
    func atg_orgqr(out__: *C_tensor, self_: *C_tensor, input2_: *C_tensor);
    func atg_orgqr_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, input2_: *C_tensor);
    func atg_ormqr(out__: *C_tensor, self_: *C_tensor, input2_: *C_tensor, input3_: *C_tensor, left_: c_int, transpose_: c_int);
    func atg_ormqr_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, input2_: *C_tensor, input3_: *C_tensor, left_: c_int, transpose_: c_int);
    func atg_pairwise_distance(out__: *C_tensor, x1_: *C_tensor, x2_: *C_tensor, p_: float64, eps_: float64, keepdim_: c_int);
    func atg_pdist(out__: *C_tensor, self_: *C_tensor, p_: float64);
    func atg_permute(out__: *C_tensor, self_: *C_tensor, dims_data int64, dims_len c_int);
    func atg_pin_memory(out__: *C_tensor, self_: *C_tensor);
    func atg_pinverse(out__: *C_tensor, self_: *C_tensor, rcond_: float64);
    func atg_pixel_shuffle(out__: *C_tensor, self_: *C_tensor, upscale_factor_: int64);
    func atg_poisson(out__: *C_tensor, self_: *C_tensor);
    func atg_poisson_nll_loss(out__: *C_tensor, input_: *C_tensor, target_: *C_tensor, log_input_: c_int, full_: c_int, eps_: float64, reduction_: int64);
    func atg_polygamma(out__: *C_tensor, n_: int64, self_: *C_tensor);
    func atg_polygamma_(out__: *C_tensor, self_: *C_tensor, n_: int64);
    func atg_polygamma_out(out__: *C_tensor, out_: *C_tensor, n_: int64, self_: *C_tensor);
    func atg_pow(out__: *C_tensor, self_: *C_tensor, exponent_: *C_scalar);
    func atg_pow1(out__: *C_tensor, self_: *C_tensor, exponent_: *C_tensor);
    func atg_pow2(out__: *C_tensor, self_scalar_: *C_scalar, exponent_: *C_tensor);
    func atg_pow_(out__: *C_tensor, self_: *C_tensor, exponent_: *C_scalar);
    func atg_pow_1(out__: *C_tensor, self_: *C_tensor, exponent_: *C_tensor);
    func atg_pow_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, exponent_: *C_scalar);
    func atg_pow_out1(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, exponent_: *C_tensor);
    func atg_pow_out2(out__: *C_tensor, out_: *C_tensor, self_scalar_: *C_scalar, exponent_: *C_tensor);
    func atg_prelu(out__: *C_tensor, self_: *C_tensor, weight_: *C_tensor);
    func atg_prelu_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, weight_: *C_tensor);
    func atg_prod(out__: *C_tensor, self_: *C_tensor, dtype_: c_int);
    func atg_prod1(out__: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int, dtype_: c_int);
    func atg_prod_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, dim_: int64, keepdim_: c_int, dtype_: c_int);
    func atg_put_(out__: *C_tensor, self_: *C_tensor, index_: *C_tensor, source_: *C_tensor, accumulate_: c_int);
    func atg_q_per_channel_scales(out__: *C_tensor, self_: *C_tensor);
    func atg_q_per_channel_zero_points(out__: *C_tensor, self_: *C_tensor);
    func atg_qr(out__: *C_tensor, self_: *C_tensor, some_: c_int);
    func atg_qr_out(out__: *C_tensor, Q_: *C_tensor, R_: *C_tensor, self_: *C_tensor, some_: c_int);
    func atg_quantize_per_channel(out__: *C_tensor, self_: *C_tensor, scales_: *C_tensor, zero_points_: *C_tensor, axis_: int64, dtype_: c_int);
    func atg_quantize_per_tensor(out__: *C_tensor, self_: *C_tensor, scale_: float64, zero_point_: int64, dtype_: c_int);
    func atg_quantized_batch_norm(out__: *C_tensor, input_: *C_tensor, weight_: *C_tensor, bias_: *C_tensor, mean_: *C_tensor, var_: *C_tensor, eps_: float64, output_scale_: float64, output_zero_point_: int64);
    func atg_quantized_gru(out__: *C_tensor, input_: *C_tensor, hx_: *C_tensor, params_data *C_tensor, params_len c_int, has_biases_: c_int, num_layers_: int64, dropout_: float64, train_: c_int, bidirectional_: c_int, batch_first_: c_int);
    func atg_quantized_gru1(out__: *C_tensor, data_: *C_tensor, batch_sizes_: *C_tensor, hx_: *C_tensor, params_data *C_tensor, params_len c_int, has_biases_: c_int, num_layers_: int64, dropout_: float64, train_: c_int, bidirectional_: c_int);
    func atg_quantized_gru_cell(out__: *C_tensor, input_: *C_tensor, hx_: *C_tensor, w_ih_: *C_tensor, w_hh_: *C_tensor, b_ih_: *C_tensor, b_hh_: *C_tensor, packed_ih_: *C_tensor, packed_hh_: *C_tensor, col_offsets_ih_: *C_tensor, col_offsets_hh_: *C_tensor, scale_ih_: *C_scalar, scale_hh_: *C_scalar, zero_point_ih_: *C_scalar, zero_point_hh_: *C_scalar);
    func atg_quantized_lstm(out__: *C_tensor, input_: *C_tensor, hx_data *C_tensor, hx_len c_int, params_data *C_tensor, params_len c_int, has_biases_: c_int, num_layers_: int64, dropout_: float64, train_: c_int, bidirectional_: c_int, batch_first_: c_int, dtype_: c_int, use_dynamic_: c_int);
    func atg_quantized_lstm1(out__: *C_tensor, data_: *C_tensor, batch_sizes_: *C_tensor, hx_data *C_tensor, hx_len c_int, params_data *C_tensor, params_len c_int, has_biases_: c_int, num_layers_: int64, dropout_: float64, train_: c_int, bidirectional_: c_int, dtype_: c_int, use_dynamic_: c_int);
    func atg_quantized_lstm_cell(out__: *C_tensor, input_: *C_tensor, hx_data *C_tensor, hx_len c_int, w_ih_: *C_tensor, w_hh_: *C_tensor, b_ih_: *C_tensor, b_hh_: *C_tensor, packed_ih_: *C_tensor, packed_hh_: *C_tensor, col_offsets_ih_: *C_tensor, col_offsets_hh_: *C_tensor, scale_ih_: *C_scalar, scale_hh_: *C_scalar, zero_point_ih_: *C_scalar, zero_point_hh_: *C_scalar);
    func atg_quantized_max_pool2d(out__: *C_tensor, self_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int, ceil_mode_: c_int);
    func atg_quantized_rnn_relu_cell(out__: *C_tensor, input_: *C_tensor, hx_: *C_tensor, w_ih_: *C_tensor, w_hh_: *C_tensor, b_ih_: *C_tensor, b_hh_: *C_tensor, packed_ih_: *C_tensor, packed_hh_: *C_tensor, col_offsets_ih_: *C_tensor, col_offsets_hh_: *C_tensor, scale_ih_: *C_scalar, scale_hh_: *C_scalar, zero_point_ih_: *C_scalar, zero_point_hh_: *C_scalar);
    func atg_quantized_rnn_tanh_cell(out__: *C_tensor, input_: *C_tensor, hx_: *C_tensor, w_ih_: *C_tensor, w_hh_: *C_tensor, b_ih_: *C_tensor, b_hh_: *C_tensor, packed_ih_: *C_tensor, packed_hh_: *C_tensor, col_offsets_ih_: *C_tensor, col_offsets_hh_: *C_tensor, scale_ih_: *C_scalar, scale_hh_: *C_scalar, zero_point_ih_: *C_scalar, zero_point_hh_: *C_scalar);
    func atg_rand(out__: *C_tensor, size_data int64, size_len c_int, options_kind c_int, options_device c_int);
    func atg_rand_like(out__: *C_tensor, self_: *C_tensor);
    func atg_rand_out(out__: *C_tensor, out_: *C_tensor, size_data int64, size_len c_int);
    func atg_randint(out__: *C_tensor, high_: int64, size_data int64, size_len c_int, options_kind c_int, options_device c_int);
    func atg_randint1(out__: *C_tensor, low_: int64, high_: int64, size_data int64, size_len c_int, options_kind c_int, options_device c_int);
    func atg_randint_like(out__: *C_tensor, self_: *C_tensor, high_: int64);
    func atg_randint_like1(out__: *C_tensor, self_: *C_tensor, low_: int64, high_: int64);
    func atg_randint_out(out__: *C_tensor, out_: *C_tensor, high_: int64, size_data int64, size_len c_int);
    func atg_randint_out1(out__: *C_tensor, out_: *C_tensor, low_: int64, high_: int64, size_data int64, size_len c_int);
    func atg_randn(out__: *C_tensor, size_data int64, size_len c_int, options_kind c_int, options_device c_int);
    func atg_randn_like(out__: *C_tensor, self_: *C_tensor);
    func atg_randn_out(out__: *C_tensor, out_: *C_tensor, size_data int64, size_len c_int);
    func atg_random_(out__: *C_tensor, self_: *C_tensor);
    func atg_random_1(out__: *C_tensor, self_: *C_tensor, to_: int64);
    func atg_random_2(out__: *C_tensor, self_: *C_tensor, from_: int64, to_: int64);
    func atg_randperm(out__: *C_tensor, n_: int64, options_kind c_int, options_device c_int);
    func atg_randperm_out(out__: *C_tensor, out_: *C_tensor, n_: int64);
    func atg_range(out__: *C_tensor, start_: *C_scalar, end_: *C_scalar, options_kind c_int, options_device c_int);
    func atg_range1(out__: *C_tensor, start_: *C_scalar, end_: *C_scalar, options_kind c_int, options_device c_int);
    func atg_range_out(out__: *C_tensor, out_: *C_tensor, start_: *C_scalar, end_: *C_scalar);
    func atg_real(out__: *C_tensor, self_: *C_tensor);
    func atg_reciprocal(out__: *C_tensor, self_: *C_tensor);
    func atg_reciprocal_(out__: *C_tensor, self_: *C_tensor);
    func atg_reciprocal_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_reflection_pad1d(out__: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_reflection_pad1d_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_reflection_pad1d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_reflection_pad1d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_reflection_pad2d(out__: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_reflection_pad2d_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_reflection_pad2d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_reflection_pad2d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_relu(out__: *C_tensor, self_: *C_tensor);
    func atg_relu_(out__: *C_tensor, self_: *C_tensor);
    func atg_remainder(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_remainder1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_remainder_(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_remainder_1(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_remainder_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_remainder_out1(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_renorm(out__: *C_tensor, self_: *C_tensor, p_: *C_scalar, dim_: int64, maxnorm_: *C_scalar);
    func atg_renorm_(out__: *C_tensor, self_: *C_tensor, p_: *C_scalar, dim_: int64, maxnorm_: *C_scalar);
    func atg_renorm_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, p_: *C_scalar, dim_: int64, maxnorm_: *C_scalar);
    func atg_repeat(out__: *C_tensor, self_: *C_tensor, repeats_data int64, repeats_len c_int);
    func atg_repeat_interleave(out__: *C_tensor, repeats_: *C_tensor);
    func atg_repeat_interleave1(out__: *C_tensor, self_: *C_tensor, repeats_: *C_tensor, dim_: int64);
    func atg_repeat_interleave2(out__: *C_tensor, self_: *C_tensor, repeats_: int64, dim_: int64);
    func atg_replication_pad1d(out__: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_replication_pad1d_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_replication_pad1d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_replication_pad1d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_replication_pad2d(out__: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_replication_pad2d_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_replication_pad2d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_replication_pad2d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_replication_pad3d(out__: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_replication_pad3d_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_replication_pad3d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_replication_pad3d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, padding_data int64, padding_len c_int);
    func atg_requires_grad_(out__: *C_tensor, self_: *C_tensor, _requires_grad_: c_int);
    func atg_reshape(out__: *C_tensor, self_: *C_tensor, shape_data int64, shape_len c_int);
    func atg_reshape_as(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_resize_(out__: *C_tensor, self_: *C_tensor, size_data int64, size_len c_int);
    func atg_resize_as_(out__: *C_tensor, self_: *C_tensor, the_template_: *C_tensor);
    func atg_rfft(out__: *C_tensor, self_: *C_tensor, signal_ndim_: int64, normalized_: c_int, onesided_: c_int);
    func atg_rnn_relu(out__: *C_tensor, input_: *C_tensor, hx_: *C_tensor, params_data *C_tensor, params_len c_int, has_biases_: c_int, num_layers_: int64, dropout_: float64, train_: c_int, bidirectional_: c_int, batch_first_: c_int);
    func atg_rnn_relu1(out__: *C_tensor, data_: *C_tensor, batch_sizes_: *C_tensor, hx_: *C_tensor, params_data *C_tensor, params_len c_int, has_biases_: c_int, num_layers_: int64, dropout_: float64, train_: c_int, bidirectional_: c_int);
    func atg_rnn_relu_cell(out__: *C_tensor, input_: *C_tensor, hx_: *C_tensor, w_ih_: *C_tensor, w_hh_: *C_tensor, b_ih_: *C_tensor, b_hh_: *C_tensor);
    func atg_rnn_tanh(out__: *C_tensor, input_: *C_tensor, hx_: *C_tensor, params_data *C_tensor, params_len c_int, has_biases_: c_int, num_layers_: int64, dropout_: float64, train_: c_int, bidirectional_: c_int, batch_first_: c_int);
    func atg_rnn_tanh1(out__: *C_tensor, data_: *C_tensor, batch_sizes_: *C_tensor, hx_: *C_tensor, params_data *C_tensor, params_len c_int, has_biases_: c_int, num_layers_: int64, dropout_: float64, train_: c_int, bidirectional_: c_int);
    func atg_rnn_tanh_cell(out__: *C_tensor, input_: *C_tensor, hx_: *C_tensor, w_ih_: *C_tensor, w_hh_: *C_tensor, b_ih_: *C_tensor, b_hh_: *C_tensor);
    func atg_roll(out__: *C_tensor, self_: *C_tensor, shifts_data int64, shifts_len c_int, dims_data int64, dims_len c_int);
    func atg_rot90(out__: *C_tensor, self_: *C_tensor, k_: int64, dims_data int64, dims_len c_int);
    func atg_round(out__: *C_tensor, self_: *C_tensor);
    func atg_round_(out__: *C_tensor, self_: *C_tensor);
    func atg_round_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_rrelu(out__: *C_tensor, self_: *C_tensor, training_: c_int);
    func atg_rrelu_(out__: *C_tensor, self_: *C_tensor, training_: c_int);
    func atg_rrelu_with_noise(out__: *C_tensor, self_: *C_tensor, noise_: *C_tensor, training_: c_int);
    func atg_rrelu_with_noise_(out__: *C_tensor, self_: *C_tensor, noise_: *C_tensor, training_: c_int);
    func atg_rrelu_with_noise_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, noise_: *C_tensor, lower_: *C_scalar, upper_: *C_scalar, training_: c_int, self_is_result_: c_int);
    func atg_rrelu_with_noise_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, noise_: *C_tensor, training_: c_int);
    func atg_rsqrt(out__: *C_tensor, self_: *C_tensor);
    func atg_rsqrt_(out__: *C_tensor, self_: *C_tensor);
    func atg_rsqrt_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_rsub(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_rsub1(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_scalar_tensor(out__: *C_tensor, s_: *C_scalar, options_kind c_int, options_device c_int);
    func atg_scatter(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, src_: *C_tensor);
    func atg_scatter1(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, value_: *C_scalar);
    func atg_scatter_(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, src_: *C_tensor);
    func atg_scatter_1(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, value_: *C_scalar);
    func atg_scatter_add(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, src_: *C_tensor);
    func atg_scatter_add_(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: *C_tensor, src_: *C_tensor);
    func atg_select(out__: *C_tensor, self_: *C_tensor, dim_: int64, index_: int64);
    func atg_selu(out__: *C_tensor, self_: *C_tensor);
    func atg_selu_(out__: *C_tensor, self_: *C_tensor);
    func atg_set_(out__: *C_tensor, self_: *C_tensor);
    func atg_set_1(out__: *C_tensor, self_: *C_tensor, source_: *C_tensor);
    func atg_set_requires_grad(out__: *C_tensor, self_: *C_tensor, r_: c_int);
    func atg_sigmoid(out__: *C_tensor, self_: *C_tensor);
    func atg_sigmoid_(out__: *C_tensor, self_: *C_tensor);
    func atg_sigmoid_backward(out__: *C_tensor, grad_output_: *C_tensor, output_: *C_tensor);
    func atg_sigmoid_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, output_: *C_tensor);
    func atg_sigmoid_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_sign(out__: *C_tensor, self_: *C_tensor);
    func atg_sign_(out__: *C_tensor, self_: *C_tensor);
    func atg_sign_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_sin(out__: *C_tensor, self_: *C_tensor);
    func atg_sin_(out__: *C_tensor, self_: *C_tensor);
    func atg_sin_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_sinh(out__: *C_tensor, self_: *C_tensor);
    func atg_sinh_(out__: *C_tensor, self_: *C_tensor);
    func atg_sinh_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_slice(out__: *C_tensor, self_: *C_tensor, dim_: int64, start_: int64, end_: int64, step_: int64);
    func atg_slogdet(out__: *C_tensor, self_: *C_tensor);
    func atg_slow_conv3d(out__: *C_tensor, self_: *C_tensor, weight_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int);
    func atg_slow_conv3d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, weight_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int);
    func atg_slow_conv_dilated2d(out__: *C_tensor, self_: *C_tensor, weight_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int);
    func atg_slow_conv_dilated3d(out__: *C_tensor, self_: *C_tensor, weight_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, dilation_data int64, dilation_len c_int);
    func atg_slow_conv_transpose2d(out__: *C_tensor, self_: *C_tensor, weight_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, output_padding_data int64, output_padding_len c_int, dilation_data int64, dilation_len c_int);
    func atg_slow_conv_transpose2d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, weight_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, output_padding_data int64, output_padding_len c_int, dilation_data int64, dilation_len c_int);
    func atg_slow_conv_transpose3d(out__: *C_tensor, self_: *C_tensor, weight_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, output_padding_data int64, output_padding_len c_int, dilation_data int64, dilation_len c_int);
    func atg_slow_conv_transpose3d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, weight_: *C_tensor, kernel_size_data int64, kernel_size_len c_int, bias_: *C_tensor, stride_data int64, stride_len c_int, padding_data int64, padding_len c_int, output_padding_data int64, output_padding_len c_int, dilation_data int64, dilation_len c_int);
    func atg_smm(out__: *C_tensor, self_: *C_tensor, mat2_: *C_tensor);
    func atg_smooth_l1_loss(out__: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_smooth_l1_loss_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_smooth_l1_loss_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_smooth_l1_loss_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_soft_margin_loss(out__: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_soft_margin_loss_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_soft_margin_loss_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_soft_margin_loss_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, target_: *C_tensor, reduction_: int64);
    func atg_softmax(out__: *C_tensor, self_: *C_tensor, dim_: int64, dtype_: c_int);
    func atg_softplus(out__: *C_tensor, self_: *C_tensor);
    func atg_softplus_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, beta_: *C_scalar, threshold_: *C_scalar, output_: *C_tensor);
    func atg_softplus_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, beta_: *C_scalar, threshold_: *C_scalar, output_: *C_tensor);
    func atg_softplus_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_softshrink(out__: *C_tensor, self_: *C_tensor);
    func atg_softshrink_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, lambd_: *C_scalar);
    func atg_softshrink_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, lambd_: *C_scalar);
    func atg_softshrink_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_solve(out__: *C_tensor, self_: *C_tensor, A_: *C_tensor);
    func atg_solve_out(out__: *C_tensor, solution_: *C_tensor, lu_: *C_tensor, self_: *C_tensor, A_: *C_tensor);
    func atg_sort(out__: *C_tensor, self_: *C_tensor, dim_: int64, descending_: c_int);
    func atg_sort_out(out__: *C_tensor, values_: *C_tensor, indices_: *C_tensor, self_: *C_tensor, dim_: int64, descending_: c_int);
    func atg_sparse_coo_tensor(out__: *C_tensor, size_data int64, size_len c_int, options_kind c_int, options_device c_int);
    func atg_sparse_coo_tensor1(out__: *C_tensor, indices_: *C_tensor, values_: *C_tensor, options_kind c_int, options_device c_int);
    func atg_sparse_coo_tensor2(out__: *C_tensor, indices_: *C_tensor, values_: *C_tensor, size_data int64, size_len c_int, options_kind c_int, options_device c_int);
    func atg_sparse_mask(out__: *C_tensor, self_: *C_tensor, mask_: *C_tensor);
    func atg_sparse_resize_(out__: *C_tensor, self_: *C_tensor, size_data int64, size_len c_int, sparse_dim_: int64, dense_dim_: int64);
    func atg_sparse_resize_and_clear_(out__: *C_tensor, self_: *C_tensor, size_data int64, size_len c_int, sparse_dim_: int64, dense_dim_: int64);
    func atg_split(self_: *C_tensor, split_size_: int64, dim_: int64) -> *C_tensor;
    func atg_split_with_sizes(self_: *C_tensor, split_sizes_data int64, split_sizes_len c_int, dim_: int64) -> *C_tensor;
    func atg_sqrt(out__: *C_tensor, self_: *C_tensor);
    func atg_sqrt_(out__: *C_tensor, self_: *C_tensor);
    func atg_sqrt_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_square(out__: *C_tensor, self_: *C_tensor);
    func atg_square_(out__: *C_tensor, self_: *C_tensor);
    func atg_squeeze(out__: *C_tensor, self_: *C_tensor);
    func atg_squeeze1(out__: *C_tensor, self_: *C_tensor, dim_: int64);
    func atg_squeeze_(out__: *C_tensor, self_: *C_tensor);
    func atg_squeeze_1(out__: *C_tensor, self_: *C_tensor, dim_: int64);
    func atg_sspaddmm(out__: *C_tensor, self_: *C_tensor, mat1_: *C_tensor, mat2_: *C_tensor);
    func atg_sspaddmm_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, mat1_: *C_tensor, mat2_: *C_tensor);
    func atg_stack(out__: *C_tensor, tensors_data *C_tensor, tensors_len c_int, dim_: int64);
    func atg_stack_out(out__: *C_tensor, out_: *C_tensor, tensors_data *C_tensor, tensors_len c_int, dim_: int64);
    func atg_std(out__: *C_tensor, self_: *C_tensor, unbiased_: c_int);
    func atg_std1(out__: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, unbiased_: c_int, keepdim_: c_int);
    func atg_std_mean(out__: *C_tensor, self_: *C_tensor, unbiased_: c_int);
    func atg_std_mean1(out__: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, unbiased_: c_int, keepdim_: c_int);
    func atg_std_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, unbiased_: c_int, keepdim_: c_int);
    func atg_stft(out__: *C_tensor, self_: *C_tensor, n_fft_: int64, hop_length_: int64, win_length_: int64, window_: *C_tensor, normalized_: c_int, onesided_: c_int);
    func atg_sub(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_sub1(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_sub_(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_sub_1(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_sub_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_sum(out__: *C_tensor, self_: *C_tensor, dtype_: c_int);
    func atg_sum1(out__: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, keepdim_: c_int, dtype_: c_int);
    func atg_sum_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, keepdim_: c_int, dtype_: c_int);
    func atg_sum_to_size(out__: *C_tensor, self_: *C_tensor, size_data int64, size_len c_int);
    func atg_svd(out__: *C_tensor, self_: *C_tensor, some_: c_int, compute_uv_: c_int);
    func atg_svd_out(out__: *C_tensor, U_: *C_tensor, S_: *C_tensor, V_: *C_tensor, self_: *C_tensor, some_: c_int, compute_uv_: c_int);
    func atg_symeig(out__: *C_tensor, self_: *C_tensor, eigenvectors_: c_int, upper_: c_int);
    func atg_symeig_out(out__: *C_tensor, e_: *C_tensor, V_: *C_tensor, self_: *C_tensor, eigenvectors_: c_int, upper_: c_int);
    func atg_t(out__: *C_tensor, self_: *C_tensor);
    func atg_t_(out__: *C_tensor, self_: *C_tensor);
    func atg_take(out__: *C_tensor, self_: *C_tensor, index_: *C_tensor);
    func atg_take_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, index_: *C_tensor);
    func atg_tan(out__: *C_tensor, self_: *C_tensor);
    func atg_tan_(out__: *C_tensor, self_: *C_tensor);
    func atg_tan_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_tanh(out__: *C_tensor, self_: *C_tensor);
    func atg_tanh_(out__: *C_tensor, self_: *C_tensor);
    func atg_tanh_backward(out__: *C_tensor, grad_output_: *C_tensor, output_: *C_tensor);
    func atg_tanh_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, output_: *C_tensor);
    func atg_tanh_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_tensordot(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor, dims_self_data int64, dims_self_len c_int, dims_other_data int64, dims_other_len c_int);
    func atg_threshold(out__: *C_tensor, self_: *C_tensor, threshold_: *C_scalar, value_: *C_scalar);
    func atg_threshold_(out__: *C_tensor, self_: *C_tensor, threshold_: *C_scalar, value_: *C_scalar);
    func atg_threshold_backward(out__: *C_tensor, grad_output_: *C_tensor, self_: *C_tensor, threshold_: *C_scalar);
    func atg_threshold_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, threshold_: *C_scalar, value_: *C_scalar);
    func atg_to(out__: *C_tensor, self_: *C_tensor, device_: c_int);
    func atg_to1(out__: *C_tensor, self_: *C_tensor, options_kind c_int, options_device c_int, non_blocking_: c_int, copy_: c_int);
    func atg_to2(out__: *C_tensor, self_: *C_tensor, dtype_: c_int, non_blocking_: c_int, copy_: c_int);
    func atg_to3(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor, non_blocking_: c_int, copy_: c_int);
    func atg_to4(out__: *C_tensor, self_: *C_tensor, device_: c_int, dtype_: c_int, non_blocking_: c_int, copy_: c_int);
    func atg_to_dense(out__: *C_tensor, self_: *C_tensor);
    func atg_to_dense_backward(out__: *C_tensor, grad_: *C_tensor, input_: *C_tensor);
    func atg_to_mkldnn(out__: *C_tensor, self_: *C_tensor);
    func atg_to_mkldnn_backward(out__: *C_tensor, grad_: *C_tensor, input_: *C_tensor);
    func atg_to_sparse(out__: *C_tensor, self_: *C_tensor);
    func atg_to_sparse1(out__: *C_tensor, self_: *C_tensor, sparse_dim_: int64);
    func atg_topk(out__: *C_tensor, self_: *C_tensor, k_: int64, dim_: int64, largest_: c_int, sorted_: c_int);
    func atg_topk_out(out__: *C_tensor, values_: *C_tensor, indices_: *C_tensor, self_: *C_tensor, k_: int64, dim_: int64, largest_: c_int, sorted_: c_int);
    func atg_totype(out__: *C_tensor, self_: *C_tensor, scalar_type_: c_int);
    func atg_trace(out__: *C_tensor, self_: *C_tensor);
    func atg_transpose(out__: *C_tensor, self_: *C_tensor, dim0_: int64, dim1_: int64);
    func atg_transpose_(out__: *C_tensor, self_: *C_tensor, dim0_: int64, dim1_: int64);
    func atg_trapz(out__: *C_tensor, y_: *C_tensor, x_: *C_tensor, dim_: int64);
    func atg_trapz1(out__: *C_tensor, y_: *C_tensor, dx_: float64, dim_: int64);
    func atg_triangular_solve(out__: *C_tensor, self_: *C_tensor, A_: *C_tensor, upper_: c_int, transpose_: c_int, unitriangular_: c_int);
    func atg_triangular_solve_out(out__: *C_tensor, X_: *C_tensor, M_: *C_tensor, self_: *C_tensor, A_: *C_tensor, upper_: c_int, transpose_: c_int, unitriangular_: c_int);
    func atg_tril(out__: *C_tensor, self_: *C_tensor, diagonal_: int64);
    func atg_tril_(out__: *C_tensor, self_: *C_tensor, diagonal_: int64);
    func atg_tril_indices(out__: *C_tensor, row_: int64, col_: int64, offset_: int64, options_kind c_int, options_device c_int);
    func atg_tril_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, diagonal_: int64);
    func atg_triplet_margin_loss(out__: *C_tensor, anchor_: *C_tensor, positive_: *C_tensor, negative_: *C_tensor, margin_: float64, p_: float64, eps_: float64, swap_: c_int, reduction_: int64);
    func atg_triu(out__: *C_tensor, self_: *C_tensor, diagonal_: int64);
    func atg_triu_(out__: *C_tensor, self_: *C_tensor, diagonal_: int64);
    func atg_triu_indices(out__: *C_tensor, row_: int64, col_: int64, offset_: int64, options_kind c_int, options_device c_int);
    func atg_triu_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, diagonal_: int64);
    func atg_true_divide(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_true_divide1(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_true_divide_(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_true_divide_1(out__: *C_tensor, self_: *C_tensor, other_: *C_scalar);
    func atg_true_divide_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_trunc(out__: *C_tensor, self_: *C_tensor);
    func atg_trunc_(out__: *C_tensor, self_: *C_tensor);
    func atg_trunc_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor);
    func atg_type_as(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_unbind(self_: *C_tensor, dim_: int64) -> *C_tensor;
    func atg_unfold(out__: *C_tensor, self_: *C_tensor, dimension_: int64, size_: int64, step_: int64);
    func atg_uniform_(out__: *C_tensor, self_: *C_tensor, from_: float64, to_: float64);
    func atg_unique_consecutive(out__: *C_tensor, self_: *C_tensor, return_inverse_: c_int, return_counts_: c_int, dim_: int64);
    func atg_unique_dim(out__: *C_tensor, self_: *C_tensor, dim_: int64, sorted_: c_int, return_inverse_: c_int, return_counts_: c_int);
    func atg_unique_dim_consecutive(out__: *C_tensor, self_: *C_tensor, dim_: int64, return_inverse_: c_int, return_counts_: c_int);
    func atg_unsqueeze(out__: *C_tensor, self_: *C_tensor, dim_: int64);
    func atg_unsqueeze_(out__: *C_tensor, self_: *C_tensor, dim_: int64);
    func atg_upsample_bicubic2d(out__: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int, align_corners_: c_int, scales_h_: float64, scales_w_: float64);
    func atg_upsample_bicubic2d_backward(out__: *C_tensor, grad_output_: *C_tensor, output_size_data int64, output_size_len c_int, input_size_data int64, input_size_len c_int, align_corners_: c_int, scales_h_: float64, scales_w_: float64);
    func atg_upsample_bicubic2d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, output_size_data int64, output_size_len c_int, input_size_data int64, input_size_len c_int, align_corners_: c_int, scales_h_: float64, scales_w_: float64);
    func atg_upsample_bicubic2d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int, align_corners_: c_int, scales_h_: float64, scales_w_: float64);
    func atg_upsample_bilinear2d(out__: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int, align_corners_: c_int, scales_h_: float64, scales_w_: float64);
    func atg_upsample_bilinear2d_backward(out__: *C_tensor, grad_output_: *C_tensor, output_size_data int64, output_size_len c_int, input_size_data int64, input_size_len c_int, align_corners_: c_int, scales_h_: float64, scales_w_: float64);
    func atg_upsample_bilinear2d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, output_size_data int64, output_size_len c_int, input_size_data int64, input_size_len c_int, align_corners_: c_int, scales_h_: float64, scales_w_: float64);
    func atg_upsample_bilinear2d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int, align_corners_: c_int, scales_h_: float64, scales_w_: float64);
    func atg_upsample_linear1d(out__: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int, align_corners_: c_int, scales_: float64);
    func atg_upsample_linear1d_backward(out__: *C_tensor, grad_output_: *C_tensor, output_size_data int64, output_size_len c_int, input_size_data int64, input_size_len c_int, align_corners_: c_int, scales_: float64);
    func atg_upsample_linear1d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, output_size_data int64, output_size_len c_int, input_size_data int64, input_size_len c_int, align_corners_: c_int, scales_: float64);
    func atg_upsample_linear1d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int, align_corners_: c_int, scales_: float64);
    func atg_upsample_nearest1d(out__: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int, scales_: float64);
    func atg_upsample_nearest1d_backward(out__: *C_tensor, grad_output_: *C_tensor, output_size_data int64, output_size_len c_int, input_size_data int64, input_size_len c_int, scales_: float64);
    func atg_upsample_nearest1d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, output_size_data int64, output_size_len c_int, input_size_data int64, input_size_len c_int, scales_: float64);
    func atg_upsample_nearest1d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int, scales_: float64);
    func atg_upsample_nearest2d(out__: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int, scales_h_: float64, scales_w_: float64);
    func atg_upsample_nearest2d_backward(out__: *C_tensor, grad_output_: *C_tensor, output_size_data int64, output_size_len c_int, input_size_data int64, input_size_len c_int, scales_h_: float64, scales_w_: float64);
    func atg_upsample_nearest2d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, output_size_data int64, output_size_len c_int, input_size_data int64, input_size_len c_int, scales_h_: float64, scales_w_: float64);
    func atg_upsample_nearest2d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int, scales_h_: float64, scales_w_: float64);
    func atg_upsample_nearest3d(out__: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int, scales_d_: float64, scales_h_: float64, scales_w_: float64);
    func atg_upsample_nearest3d_backward(out__: *C_tensor, grad_output_: *C_tensor, output_size_data int64, output_size_len c_int, input_size_data int64, input_size_len c_int, scales_d_: float64, scales_h_: float64, scales_w_: float64);
    func atg_upsample_nearest3d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, output_size_data int64, output_size_len c_int, input_size_data int64, input_size_len c_int, scales_d_: float64, scales_h_: float64, scales_w_: float64);
    func atg_upsample_nearest3d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int, scales_d_: float64, scales_h_: float64, scales_w_: float64);
    func atg_upsample_trilinear3d(out__: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int, align_corners_: c_int, scales_d_: float64, scales_h_: float64, scales_w_: float64);
    func atg_upsample_trilinear3d_backward(out__: *C_tensor, grad_output_: *C_tensor, output_size_data int64, output_size_len c_int, input_size_data int64, input_size_len c_int, align_corners_: c_int, scales_d_: float64, scales_h_: float64, scales_w_: float64);
    func atg_upsample_trilinear3d_backward_out(out__: *C_tensor, grad_input_: *C_tensor, grad_output_: *C_tensor, output_size_data int64, output_size_len c_int, input_size_data int64, input_size_len c_int, align_corners_: c_int, scales_d_: float64, scales_h_: float64, scales_w_: float64);
    func atg_upsample_trilinear3d_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, output_size_data int64, output_size_len c_int, align_corners_: c_int, scales_d_: float64, scales_h_: float64, scales_w_: float64);
    func atg_values(out__: *C_tensor, self_: *C_tensor);
    func atg_var(out__: *C_tensor, self_: *C_tensor, unbiased_: c_int);
    func atg_var1(out__: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, unbiased_: c_int, keepdim_: c_int);
    func atg_var_mean(out__: *C_tensor, self_: *C_tensor, unbiased_: c_int);
    func atg_var_mean1(out__: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, unbiased_: c_int, keepdim_: c_int);
    func atg_var_out(out__: *C_tensor, out_: *C_tensor, self_: *C_tensor, dim_data int64, dim_len c_int, unbiased_: c_int, keepdim_: c_int);
    func atg_view(out__: *C_tensor, self_: *C_tensor, size_data int64, size_len c_int);
    func atg_view_as(out__: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_where(condition_: *C_tensor) -> *C_tensor;
    func atg_where1(out__: *C_tensor, condition_: *C_tensor, self_: *C_tensor, other_: *C_tensor);
    func atg_zero_(out__: *C_tensor, self_: *C_tensor);
    func atg_zeros(out__: *C_tensor, size_data int64, size_len c_int, options_kind c_int, options_device c_int);
    func atg_zeros_like(out__: *C_tensor, self_: *C_tensor);
    func atg_zeros_out(out__: *C_tensor, out_: *C_tensor, size_data int64, size_len c_int);
}
