/* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT BY HAND! */
package libtch

func ptr_list(l []Tensor) []*C_tensor {
    var retVal []*C_tensor 
    for _, x := range l{ 
      retVal = append(retVal, x) 
    } 
} 


func f_internal_and_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___and__(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_and_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___and__1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_iand_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___iand__(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_iand_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___iand__1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_ilshift_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___ilshift__(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_ilshift_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___ilshift__1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_ior_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___ior__(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_ior_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___ior__1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_irshift_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___irshift__(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_irshift_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___irshift__1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_ixor_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___ixor__(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_ixor_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___ixor__1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_lshift_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___lshift__(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_lshift_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___lshift__1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_or_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___or__(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_or_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___or__1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_rshift_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___rshift__(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_rshift_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___rshift__1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_xor_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___xor__(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_xor_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg___xor__1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_adaptive_avg_pool2d(self Tensor, output_size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__adaptive_avg_pool2d(c_tensors, self.c_tensor, output_size.as_ptr(), output_size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_adaptive_avg_pool2d_backward(self Tensor, grad_output Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__adaptive_avg_pool2d_backward(c_tensors, grad_output.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_addr(self Tensor, vec1 Tensor, vec2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__addr(c_tensors, self.c_tensor, vec1.c_tensor, vec2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_addr_(self Tensor, vec1 Tensor, vec2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__addr_(c_tensors, self.c_tensor, vec1.c_tensor, vec2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_addr_out(self Tensor, out Tensor, vec1 Tensor, vec2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__addr_out(c_tensors, out.c_tensor, self.c_tensor, vec1.c_tensor, vec2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_amp_update_scale(self Tensor, growth_tracker Tensor, current_scale Tensor, found_inf Tensor, scale_growth_factor float64, scale_backoff_factor float64, growth_interval int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__amp_update_scale(c_tensors, growth_tracker.c_tensor, current_scale.c_tensor, found_inf.c_tensor, scale_growth_factor, scale_backoff_factor, growth_interval) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_baddbmm_mkl_(self Tensor, batch1 Tensor, batch2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__baddbmm_mkl_(c_tensors, self.c_tensor, batch1.c_tensor, batch2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cast_byte(self Tensor, non_blocking bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cast_byte(c_tensors, self.c_tensor, if non_blocking { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cast_char(self Tensor, non_blocking bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cast_char(c_tensors, self.c_tensor, if non_blocking { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cast_double(self Tensor, non_blocking bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cast_double(c_tensors, self.c_tensor, if non_blocking { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cast_float(self Tensor, non_blocking bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cast_float(c_tensors, self.c_tensor, if non_blocking { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cast_half(self Tensor, non_blocking bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cast_half(c_tensors, self.c_tensor, if non_blocking { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cast_int(self Tensor, non_blocking bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cast_int(c_tensors, self.c_tensor, if non_blocking { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cast_long(self Tensor, non_blocking bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cast_long(c_tensors, self.c_tensor, if non_blocking { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cast_short(self Tensor, non_blocking bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cast_short(c_tensors, self.c_tensor, if non_blocking { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_catTensor(self Tensor, tensors []Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cat(c_tensors, ptr_list(tensors).as_ptr(), tensors.len() int32, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cat_outTensor(self Tensor, out Tensor, tensors []Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cat_out(c_tensors, out.c_tensor, ptr_list(tensors).as_ptr(), tensors.len() int32, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cdist_backward(self Tensor, grad Tensor, x1 Tensor, x2 Tensor, p float64, cdist Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cdist_backward(c_tensors, grad.c_tensor, x1.c_tensor, x2.c_tensor, p, cdist.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cholesky_helper(self Tensor, upper bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cholesky_helper(c_tensors, self.c_tensor, if upper { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cholesky_solve_helper(self Tensor, a Tensor, upper bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cholesky_solve_helper(c_tensors, self.c_tensor, a.c_tensor, if upper { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_coalesced_(self Tensor, coalesced bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__coalesced_(c_tensors, self.c_tensor, if coalesced { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_convolutionTensor(self Tensor, input Tensor, weight Tensor, bias TensorOption, stride []int64, padding []int64, dilation []int64, transposed bool, output_padding []int64, groups int64, benchmark bool, deterministic bool, cudnn_enabled bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__convolution(c_tensors, input.c_tensor, weight.c_tensor, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if transposed { 1 } else { 0 }, output_padding.as_ptr(), output_padding.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }, if cudnn_enabled { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_convolution_nogroupTensor(self Tensor, input Tensor, weight Tensor, bias TensorOption, stride []int64, padding []int64, dilation []int64, transposed bool, output_padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__convolution_nogroup(c_tensors, input.c_tensor, weight.c_tensor, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if transposed { 1 } else { 0 }, output_padding.as_ptr(), output_padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_copy_from(self Tensor, dst Tensor, non_blocking bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__copy_from(c_tensors, self.c_tensor, dst.c_tensor, if non_blocking { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_ctc_loss(self Tensor, log_probs Tensor, targets Tensor, input_lengths []int64, target_lengths []int64, blank int64, zero_infinity bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__ctc_loss(c_tensors, log_probs.c_tensor, targets.c_tensor, input_lengths.as_ptr(), input_lengths.len() int32, target_lengths.as_ptr(), target_lengths.len() int32, blank, if zero_infinity { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_ctc_loss_backward(self Tensor, grad Tensor, log_probs Tensor, targets Tensor, input_lengths []int64, target_lengths []int64, neg_log_likelihood Tensor, log_alpha Tensor, blank int64, zero_infinity bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__ctc_loss_backward(c_tensors, grad.c_tensor, log_probs.c_tensor, targets.c_tensor, input_lengths.as_ptr(), input_lengths.len() int32, target_lengths.as_ptr(), target_lengths.len() int32, neg_log_likelihood.c_tensor, log_alpha.c_tensor, blank, if zero_infinity { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cudnn_ctc_loss(self Tensor, log_probs Tensor, targets Tensor, input_lengths []int64, target_lengths []int64, blank int64, deterministic bool, zero_infinity bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__cudnn_ctc_loss(c_tensors, log_probs.c_tensor, targets.c_tensor, input_lengths.as_ptr(), input_lengths.len() int32, target_lengths.as_ptr(), target_lengths.len() int32, blank, if deterministic { 1 } else { 0 }, if zero_infinity { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_cudnn_init_dropout_state(self Tensor, dropout float64, train bool, dropout_seed int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cudnn_init_dropout_state(c_tensors, dropout, if train { 1 } else { 0 }, dropout_seed, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cudnn_rnnTensor(self Tensor, input Tensor, weight []Tensor, weight_stride0 int64, weight_buf TensorOption, hx Tensor, cx TensorOption, mode int64, hidden_size int64, num_layers int64, batch_first bool, dropout float64, train bool, bidirectional bool, batch_sizes []int64, dropout_state TensorOption)(error, (Tensor, Tensor, Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 5) 
    unsafe_torch_err({ 
        atg__cudnn_rnn(c_tensors, input.c_tensor, ptr_list(weight).as_ptr(), weight.len() int32, weight_stride0, weight_buf.c_tensor), hx.c_tensor, cx.c_tensor), mode, hidden_size, num_layers, if batch_first { 1 } else { 0 }, dropout, if train { 1 } else { 0 }, if bidirectional { 1 } else { 0 }, batch_sizes.as_ptr(), batch_sizes.len() int32, dropout_state.c_tensor)) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }, Tensor { C_tensor: c_tensors[3] }, Tensor { C_tensor: c_tensors[4] }) 
} 

func f_internal_cudnn_rnn_flatten_weightTensor(self Tensor, weight_arr []Tensor, weight_stride0 int64, input_size int64, mode int64, hidden_size int64, num_layers int64, batch_first bool, bidirectional bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cudnn_rnn_flatten_weight(c_tensors, ptr_list(weight_arr).as_ptr(), weight_arr.len() int32, weight_stride0, input_size, mode, hidden_size, num_layers, if batch_first { 1 } else { 0 }, if bidirectional { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cumprod(self Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cumprod(c_tensors, self.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cumprod_out(self Tensor, out Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cumprod_out(c_tensors, out.c_tensor, self.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cumsum(self Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cumsum(c_tensors, self.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_cumsum_out(self Tensor, out Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__cumsum_out(c_tensors, out.c_tensor, self.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_dim_arange(self Tensor, like Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__dim_arange(c_tensors, like.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_dirichlet_grad(self Tensor, x Tensor, alpha Tensor, total Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__dirichlet_grad(c_tensors, x.c_tensor, alpha.c_tensor, total.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_embedding_bagTensor(self Tensor, weight Tensor, indices Tensor, offsets Tensor, scale_grad_by_freq bool, mode int64, sparse bool, per_sample_weights TensorOption, include_last_offset bool)(error, (Tensor, Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 4) 
    unsafe_torch_err({ 
        atg__embedding_bag(c_tensors, weight.c_tensor, indices.c_tensor, offsets.c_tensor, if scale_grad_by_freq { 1 } else { 0 }, mode, if sparse { 1 } else { 0 }, per_sample_weights.c_tensor), if include_last_offset { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }, Tensor { C_tensor: c_tensors[3] }) 
} 

func f_internal_embedding_bag_backwardTensor(self Tensor, grad Tensor, indices Tensor, offsets Tensor, offset2bag Tensor, bag_size Tensor, maximum_indices Tensor, num_weights int64, scale_grad_by_freq bool, mode int64, sparse bool, per_sample_weights TensorOption)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__embedding_bag_backward(c_tensors, grad.c_tensor, indices.c_tensor, offsets.c_tensor, offset2bag.c_tensor, bag_size.c_tensor, maximum_indices.c_tensor, num_weights, if scale_grad_by_freq { 1 } else { 0 }, mode, if sparse { 1 } else { 0 }, per_sample_weights.c_tensor)) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_embedding_bag_dense_backwardTensor(self Tensor, grad Tensor, indices Tensor, offsets Tensor, offset2bag Tensor, bag_size Tensor, maximum_indices Tensor, num_weights int64, scale_grad_by_freq bool, mode int64, per_sample_weights TensorOption)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__embedding_bag_dense_backward(c_tensors, grad.c_tensor, indices.c_tensor, offsets.c_tensor, offset2bag.c_tensor, bag_size.c_tensor, maximum_indices.c_tensor, num_weights, if scale_grad_by_freq { 1 } else { 0 }, mode, per_sample_weights.c_tensor)) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_embedding_bag_per_sample_weights_backward(self Tensor, grad Tensor, weight Tensor, indices Tensor, offsets Tensor, offset2bag Tensor, mode int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__embedding_bag_per_sample_weights_backward(c_tensors, grad.c_tensor, weight.c_tensor, indices.c_tensor, offsets.c_tensor, offset2bag.c_tensor, mode) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_embedding_bag_sparse_backwardTensor(self Tensor, grad Tensor, indices Tensor, offsets Tensor, offset2bag Tensor, bag_size Tensor, num_weights int64, scale_grad_by_freq bool, mode int64, per_sample_weights TensorOption)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__embedding_bag_sparse_backward(c_tensors, grad.c_tensor, indices.c_tensor, offsets.c_tensor, offset2bag.c_tensor, bag_size.c_tensor, num_weights, if scale_grad_by_freq { 1 } else { 0 }, mode, per_sample_weights.c_tensor)) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_empty_affine_quantized(self Tensor, size []int64, options (Kind, Device), scale float64, zero_point int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__empty_affine_quantized(c_tensors, size.as_ptr(), size.len() int32, options.0.c_int(), options.1.c_int(), scale, zero_point) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_empty_per_channel_affine_quantized(self Tensor, size []int64, scales Tensor, zero_points Tensor, axis int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__empty_per_channel_affine_quantized(c_tensors, size.as_ptr(), size.len() int32, scales.c_tensor, zero_points.c_tensor, axis, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_fft_with_size(self Tensor, signal_ndim int64, complex_input bool, complex_output bool, inverse bool, checked_signal_sizes []int64, normalized bool, onesided bool, output_sizes []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__fft_with_size(c_tensors, self.c_tensor, signal_ndim, if complex_input { 1 } else { 0 }, if complex_output { 1 } else { 0 }, if inverse { 1 } else { 0 }, checked_signal_sizes.as_ptr(), checked_signal_sizes.len() int32, if normalized { 1 } else { 0 }, if onesided { 1 } else { 0 }, output_sizes.as_ptr(), output_sizes.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_fused_dropout(self Tensor, p float64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__fused_dropout(c_tensors, self.c_tensor, p) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_gather_sparse_backward(self Tensor, dim int64, index Tensor, grad Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__gather_sparse_backward(c_tensors, self.c_tensor, dim, index.c_tensor, grad.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_index_copy_(self Tensor, dim int64, index Tensor, source Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__index_copy_(c_tensors, self.c_tensor, dim, index.c_tensor, source.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_index_put_impl_Tensor(self Tensor, indices []Tensor, values Tensor, accumulate bool, unsafe_ bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__index_put_impl_(c_tensors, self.c_tensor, ptr_list(indices).as_ptr(), indices.len() int32, values.c_tensor, if accumulate { 1 } else { 0 }, if unsafe_ { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_indices(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__indices(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_inverse_helper(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__inverse_helper(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_log_softmax(self Tensor, dim int64, half_to_float bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__log_softmax(c_tensors, self.c_tensor, dim, if half_to_float { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_log_softmax_backward_data(self Tensor, grad_output Tensor, output Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__log_softmax_backward_data(c_tensors, grad_output.c_tensor, output.c_tensor, dim, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_lu_solve_helper(self Tensor, lu_data Tensor, lu_pivots Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__lu_solve_helper(c_tensors, self.c_tensor, lu_data.c_tensor, lu_pivots.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_lu_with_info(self Tensor, pivot bool, check_errors bool)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg__lu_with_info(c_tensors, self.c_tensor, if pivot { 1 } else { 0 }, if check_errors { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_internal_make_per_channel_quantized_tensor(self Tensor, scale Tensor, zero_point Tensor, axis int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__make_per_channel_quantized_tensor(c_tensors, self.c_tensor, scale.c_tensor, zero_point.c_tensor, axis) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_make_per_tensor_quantized_tensor(self Tensor, scale float64, zero_point int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__make_per_tensor_quantized_tensor(c_tensors, self.c_tensor, scale, zero_point) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_masked_scale(self Tensor, mask Tensor, scale float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__masked_scale(c_tensors, self.c_tensor, mask.c_tensor, scale) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_max(self Tensor, dim int64, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__max(c_tensors, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_max_out(self Tensor, max Tensor, max_indices Tensor, dim int64, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__max_out(c_tensors, max.c_tensor, max_indices.c_tensor, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_min(self Tensor, dim int64, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__min(c_tensors, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_min_out(self Tensor, min Tensor, min_indices Tensor, dim int64, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__min_out(c_tensors, min.c_tensor, min_indices.c_tensor, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_mkldnn_reshape(self Tensor, shape []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__mkldnn_reshape(c_tensors, self.c_tensor, shape.as_ptr(), shape.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_mkldnn_transpose(self Tensor, dim0 int64, dim1 int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__mkldnn_transpose(c_tensors, self.c_tensor, dim0, dim1) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_mkldnn_transpose_(self Tensor, dim0 int64, dim1 int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__mkldnn_transpose_(c_tensors, self.c_tensor, dim0, dim1) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_mode(self Tensor, dim int64, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__mode(c_tensors, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_mode_out(self Tensor, values Tensor, indices Tensor, dim int64, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__mode_out(c_tensors, values.c_tensor, indices.c_tensor, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_multinomial_alias_draw(self Tensor, j Tensor, q Tensor, num_samples int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__multinomial_alias_draw(c_tensors, j.c_tensor, q.c_tensor, num_samples) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_multinomial_alias_setup(self Tensor, probs Tensor)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__multinomial_alias_setup(c_tensors, probs.c_tensor) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_nnpack_spatial_convolutionTensor(self Tensor, input Tensor, weight Tensor, bias TensorOption, padding []int64, stride []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__nnpack_spatial_convolution(c_tensors, input.c_tensor, weight.c_tensor, bias.c_tensor), padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_nnpack_spatial_convolution_backward_input(self Tensor, input Tensor, grad_output Tensor, weight Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__nnpack_spatial_convolution_backward_input(c_tensors, input.c_tensor, grad_output.c_tensor, weight.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_nnpack_spatial_convolution_backward_weight(self Tensor, input Tensor, weightsize []int64, grad_output Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__nnpack_spatial_convolution_backward_weight(c_tensors, input.c_tensor, weightsize.as_ptr(), weightsize.len() int32, grad_output.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_pack_padded_sequence(self Tensor, input Tensor, lengths Tensor, batch_first bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__pack_padded_sequence(c_tensors, input.c_tensor, lengths.c_tensor, if batch_first { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_pack_padded_sequence_backward(self Tensor, grad Tensor, input_size []int64, batch_sizes Tensor, batch_first bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__pack_padded_sequence_backward(c_tensors, grad.c_tensor, input_size.as_ptr(), input_size.len() int32, batch_sizes.c_tensor, if batch_first { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_pad_packed_sequenceScalar(self Tensor, data Tensor, batch_sizes Tensor, batch_first bool, padding_value Scalar, total_length int64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__pad_packed_sequence(c_tensors, data.c_tensor, batch_sizes.c_tensor, if batch_first { 1 } else { 0 }, padding_value.c_scalar, total_length) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_pdist_backward(self Tensor, grad Tensor, p float64, pdist Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__pdist_backward(c_tensors, grad.c_tensor, self.c_tensor, p, pdist.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_qr_helper(self Tensor, some bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__qr_helper(c_tensors, self.c_tensor, if some { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_reshape_from_tensor(self Tensor, shape Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__reshape_from_tensor(c_tensors, self.c_tensor, shape.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_s_where(self Tensor, condition Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__s_where(c_tensors, condition.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_sample_dirichlet(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__sample_dirichlet(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_shape_as_tensor(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__shape_as_tensor(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_sobol_engine_draw(self Tensor, quasi Tensor, n int64, sobolstate Tensor, dimension int64, num_generated int64, dtype Kind)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__sobol_engine_draw(c_tensors, quasi.c_tensor, n, sobolstate.c_tensor, dimension, num_generated, dtype.c_int()) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_sobol_engine_ff_(self Tensor, n int64, sobolstate Tensor, dimension int64, num_generated int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__sobol_engine_ff_(c_tensors, self.c_tensor, n, sobolstate.c_tensor, dimension, num_generated) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_sobol_engine_initialize_state_(self Tensor, dimension int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__sobol_engine_initialize_state_(c_tensors, self.c_tensor, dimension) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_sobol_engine_scramble_(self Tensor, ltm Tensor, dimension int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__sobol_engine_scramble_(c_tensors, self.c_tensor, ltm.c_tensor, dimension) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_softmax(self Tensor, dim int64, half_to_float bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__softmax(c_tensors, self.c_tensor, dim, if half_to_float { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_softmax_backward_data(self Tensor, grad_output Tensor, output Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__softmax_backward_data(c_tensors, grad_output.c_tensor, output.c_tensor, dim, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_solve_helper(self Tensor, a Tensor)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__solve_helper(c_tensors, self.c_tensor, a.c_tensor) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_sparse_addmm(self Tensor, sparse Tensor, dense Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__sparse_addmm(c_tensors, self.c_tensor, sparse.c_tensor, dense.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_sparse_coo_tensor_unsafe(self Tensor, indices Tensor, values Tensor, size []int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__sparse_coo_tensor_unsafe(c_tensors, indices.c_tensor, values.c_tensor, size.as_ptr(), size.len() int32, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_sparse_coo_tensor_with_dims(self Tensor, sparse_dim int64, dense_dim int64, size []int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__sparse_coo_tensor_with_dims(c_tensors, sparse_dim, dense_dim, size.as_ptr(), size.len() int32, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_sparse_coo_tensor_with_dims_and_tensors(self Tensor, sparse_dim int64, dense_dim int64, size []int64, indices Tensor, values Tensor, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__sparse_coo_tensor_with_dims_and_tensors(c_tensors, sparse_dim, dense_dim, size.as_ptr(), size.len() int32, indices.c_tensor, values.c_tensor, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_sparse_mm(self Tensor, sparse Tensor, dense Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__sparse_mm(c_tensors, sparse.c_tensor, dense.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_sparse_sum(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__sparse_sum(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_sparse_sum1(self Tensor, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__sparse_sum1(c_tensors, self.c_tensor, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_sparse_sum2(self Tensor, dim []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__sparse_sum2(c_tensors, self.c_tensor, dim.as_ptr(), dim.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_sparse_sum3(self Tensor, dim []int64, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__sparse_sum3(c_tensors, self.c_tensor, dim.as_ptr(), dim.len() int32, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_sparse_sum_backward(self Tensor, grad Tensor, dim []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__sparse_sum_backward(c_tensors, grad.c_tensor, self.c_tensor, dim.as_ptr(), dim.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_standard_gamma(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__standard_gamma(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_standard_gamma_grad(self Tensor, output Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__standard_gamma_grad(c_tensors, self.c_tensor, output.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_std(self Tensor, unbiased bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__std(c_tensors, self.c_tensor, if unbiased { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_svd_helper(self Tensor, some bool, compute_uv bool)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg__svd_helper(c_tensors, self.c_tensor, if some { 1 } else { 0 }, if compute_uv { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_internal_symeig_helper(self Tensor, eigenvectors bool, upper bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__symeig_helper(c_tensors, self.c_tensor, if eigenvectors { 1 } else { 0 }, if upper { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_triangular_solve_helper(self Tensor, a Tensor, upper bool, transpose bool, unitriangular bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__triangular_solve_helper(c_tensors, self.c_tensor, a.c_tensor, if upper { 1 } else { 0 }, if transpose { 1 } else { 0 }, if unitriangular { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_trilinear(self Tensor, i1 Tensor, i2 Tensor, i3 Tensor, expand1 []int64, expand2 []int64, expand3 []int64, sumdim []int64, unroll_dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__trilinear(c_tensors, i1.c_tensor, i2.c_tensor, i3.c_tensor, expand1.as_ptr(), expand1.len() int32, expand2.as_ptr(), expand2.len() int32, expand3.as_ptr(), expand3.len() int32, sumdim.as_ptr(), sumdim.len() int32, unroll_dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_unique(self Tensor, sorted bool, return_inverse bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__unique(c_tensors, self.c_tensor, if sorted { 1 } else { 0 }, if return_inverse { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_unique2(self Tensor, sorted bool, return_inverse bool, return_counts bool)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg__unique2(c_tensors, self.c_tensor, if sorted { 1 } else { 0 }, if return_inverse { 1 } else { 0 }, if return_counts { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_internal_unsafe_view(self Tensor, size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__unsafe_view(c_tensors, self.c_tensor, size.as_ptr(), size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_values(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__values(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_var(self Tensor, unbiased bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__var(c_tensors, self.c_tensor, if unbiased { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_weight_norm(self Tensor, v Tensor, g Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg__weight_norm(c_tensors, v.c_tensor, g.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_internal_weight_norm_cuda_interface(self Tensor, v Tensor, g Tensor, dim int64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__weight_norm_cuda_interface(c_tensors, v.c_tensor, g.c_tensor, dim) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_weight_norm_cuda_interface_backward(self Tensor, grad_w Tensor, saved_v Tensor, saved_g Tensor, saved_norms Tensor, dim int64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__weight_norm_cuda_interface_backward(c_tensors, grad_w.c_tensor, saved_v.c_tensor, saved_g.c_tensor, saved_norms.c_tensor, dim) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_internal_weight_norm_differentiable_backward(self Tensor, grad_w Tensor, saved_v Tensor, saved_g Tensor, saved_norms Tensor, dim int64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg__weight_norm_differentiable_backward(c_tensors, grad_w.c_tensor, saved_v.c_tensor, saved_g.c_tensor, saved_norms.c_tensor, dim) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_abs(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_abs(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_abs_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_abs_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_abs_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_abs_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_acos(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_acos(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_acos_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_acos_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_acos_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_acos_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_adaptive_avg_pool1d(self Tensor, output_size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_adaptive_avg_pool1d(c_tensors, self.c_tensor, output_size.as_ptr(), output_size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_adaptive_avg_pool2d(self Tensor, output_size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_adaptive_avg_pool2d(c_tensors, self.c_tensor, output_size.as_ptr(), output_size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_adaptive_avg_pool2d_out(self Tensor, out Tensor, output_size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_adaptive_avg_pool2d_out(c_tensors, out.c_tensor, self.c_tensor, output_size.as_ptr(), output_size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_adaptive_avg_pool3d(self Tensor, output_size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_adaptive_avg_pool3d(c_tensors, self.c_tensor, output_size.as_ptr(), output_size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_adaptive_avg_pool3d_backward(self Tensor, grad_output Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_adaptive_avg_pool3d_backward(c_tensors, grad_output.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_adaptive_avg_pool3d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_adaptive_avg_pool3d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_adaptive_avg_pool3d_out(self Tensor, out Tensor, output_size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_adaptive_avg_pool3d_out(c_tensors, out.c_tensor, self.c_tensor, output_size.as_ptr(), output_size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_adaptive_max_pool1d(self Tensor, output_size []int64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_adaptive_max_pool1d(c_tensors, self.c_tensor, output_size.as_ptr(), output_size.len() int32) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_adaptive_max_pool2d(self Tensor, output_size []int64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_adaptive_max_pool2d(c_tensors, self.c_tensor, output_size.as_ptr(), output_size.len() int32) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_adaptive_max_pool2d_backward(self Tensor, grad_output Tensor, indices Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_adaptive_max_pool2d_backward(c_tensors, grad_output.c_tensor, self.c_tensor, indices.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_adaptive_max_pool2d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, indices Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_adaptive_max_pool2d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, indices.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_adaptive_max_pool2d_out(self Tensor, out Tensor, indices Tensor, output_size []int64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_adaptive_max_pool2d_out(c_tensors, out.c_tensor, indices.c_tensor, self.c_tensor, output_size.as_ptr(), output_size.len() int32) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_adaptive_max_pool3d(self Tensor, output_size []int64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_adaptive_max_pool3d(c_tensors, self.c_tensor, output_size.as_ptr(), output_size.len() int32) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_adaptive_max_pool3d_backward(self Tensor, grad_output Tensor, indices Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_adaptive_max_pool3d_backward(c_tensors, grad_output.c_tensor, self.c_tensor, indices.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_adaptive_max_pool3d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, indices Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_adaptive_max_pool3d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, indices.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_adaptive_max_pool3d_out(self Tensor, out Tensor, indices Tensor, output_size []int64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_adaptive_max_pool3d_out(c_tensors, out.c_tensor, indices.c_tensor, self.c_tensor, output_size.as_ptr(), output_size.len() int32) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_add(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_add(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_add1Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_add1(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_add_(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_add_(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_add_1Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_add_1(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_add_out(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_add_out(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addbmm(self Tensor, batch1 Tensor, batch2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addbmm(c_tensors, self.c_tensor, batch1.c_tensor, batch2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addbmm_(self Tensor, batch1 Tensor, batch2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addbmm_(c_tensors, self.c_tensor, batch1.c_tensor, batch2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addbmm_out(self Tensor, out Tensor, batch1 Tensor, batch2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addbmm_out(c_tensors, out.c_tensor, self.c_tensor, batch1.c_tensor, batch2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addcdiv(self Tensor, tensor1 Tensor, tensor2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addcdiv(c_tensors, self.c_tensor, tensor1.c_tensor, tensor2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addcdiv_(self Tensor, tensor1 Tensor, tensor2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addcdiv_(c_tensors, self.c_tensor, tensor1.c_tensor, tensor2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addcdiv_out(self Tensor, out Tensor, tensor1 Tensor, tensor2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addcdiv_out(c_tensors, out.c_tensor, self.c_tensor, tensor1.c_tensor, tensor2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addcmul(self Tensor, tensor1 Tensor, tensor2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addcmul(c_tensors, self.c_tensor, tensor1.c_tensor, tensor2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addcmul_(self Tensor, tensor1 Tensor, tensor2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addcmul_(c_tensors, self.c_tensor, tensor1.c_tensor, tensor2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addcmul_out(self Tensor, out Tensor, tensor1 Tensor, tensor2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addcmul_out(c_tensors, out.c_tensor, self.c_tensor, tensor1.c_tensor, tensor2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addmm(self Tensor, mat1 Tensor, mat2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addmm(c_tensors, self.c_tensor, mat1.c_tensor, mat2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addmm_(self Tensor, mat1 Tensor, mat2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addmm_(c_tensors, self.c_tensor, mat1.c_tensor, mat2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addmm_out(self Tensor, out Tensor, mat1 Tensor, mat2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addmm_out(c_tensors, out.c_tensor, self.c_tensor, mat1.c_tensor, mat2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addmv(self Tensor, mat Tensor, vec Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addmv(c_tensors, self.c_tensor, mat.c_tensor, vec.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addmv_(self Tensor, mat Tensor, vec Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addmv_(c_tensors, self.c_tensor, mat.c_tensor, vec.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addmv_out(self Tensor, out Tensor, mat Tensor, vec Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addmv_out(c_tensors, out.c_tensor, self.c_tensor, mat.c_tensor, vec.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addr(self Tensor, vec1 Tensor, vec2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addr(c_tensors, self.c_tensor, vec1.c_tensor, vec2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addr_(self Tensor, vec1 Tensor, vec2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addr_(c_tensors, self.c_tensor, vec1.c_tensor, vec2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_addr_out(self Tensor, out Tensor, vec1 Tensor, vec2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_addr_out(c_tensors, out.c_tensor, self.c_tensor, vec1.c_tensor, vec2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_affine_grid_generator(self Tensor, theta Tensor, size []int64, align_corners bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_affine_grid_generator(c_tensors, theta.c_tensor, size.as_ptr(), size.len() int32, if align_corners { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_affine_grid_generator_backward(self Tensor, grad Tensor, size []int64, align_corners bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_affine_grid_generator_backward(c_tensors, grad.c_tensor, size.as_ptr(), size.len() int32, if align_corners { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_alias(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_alias(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_align_as(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_align_as(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_align_tensorsTensor(self Tensor, tensors []Tensor)(error, []Tensor) { 
        c_tensors := unsafe_torch_err!({atg_align_tensors(ptr_list(tensors).as_ptr(), tensors.len() int32)}) 
        var r__ []Tensor 
        i := 0 
        for { 
            c__ := unsafe{*c_tensors.add(i)} 
            if c__.is_null() { break } 
            r__ = append(r__, Tensor {C_tensor: c__}) 
            i += 1 
        } 
        return r__ 
} 

func f_all(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_all(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_all1(self Tensor, dim int64, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_all1(c_tensors, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_all_out(self Tensor, out Tensor, dim int64, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_all_out(c_tensors, out.c_tensor, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_alpha_dropout(self Tensor, input Tensor, p float64, train bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_alpha_dropout(c_tensors, input.c_tensor, p, if train { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_alpha_dropout_(self Tensor, p float64, train bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_alpha_dropout_(c_tensors, self.c_tensor, p, if train { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_angle(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_angle(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_angle_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_angle_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_any(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_any(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_any1(self Tensor, dim int64, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_any1(c_tensors, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_any_out(self Tensor, out Tensor, dim int64, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_any_out(c_tensors, out.c_tensor, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_arangeScalar(self Tensor, end Scalar, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_arange(c_tensors, end.c_scalar, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_arange1Scalar(self Tensor, start Scalar, end Scalar, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_arange1(c_tensors, start.c_scalar, end.c_scalar, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_arange2Scalar(self Tensor, start Scalar, end Scalar, step Scalar, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_arange2(c_tensors, start.c_scalar, end.c_scalar, step.c_scalar, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_arange_outScalar(self Tensor, out Tensor, end Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_arange_out(c_tensors, out.c_tensor, end.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_arange_out1Scalar(self Tensor, out Tensor, start Scalar, end Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_arange_out1(c_tensors, out.c_tensor, start.c_scalar, end.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_argmax(self Tensor, dim int64, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_argmax(c_tensors, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_argmin(self Tensor, dim int64, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_argmin(c_tensors, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_argsort(self Tensor, dim int64, descending bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_argsort(c_tensors, self.c_tensor, dim, if descending { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_as_strided(self Tensor, size []int64, stride []int64, storage_offset int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_as_strided(c_tensors, self.c_tensor, size.as_ptr(), size.len() int32, stride.as_ptr(), stride.len() int32, storage_offset) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_as_strided_(self Tensor, size []int64, stride []int64, storage_offset int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_as_strided_(c_tensors, self.c_tensor, size.as_ptr(), size.len() int32, stride.as_ptr(), stride.len() int32, storage_offset) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_asin(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_asin(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_asin_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_asin_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_asin_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_asin_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_atan(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_atan(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_atan2(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_atan2(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_atan2_(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_atan2_(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_atan2_out(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_atan2_out(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_atan_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_atan_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_atan_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_atan_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_avg_pool1d(self Tensor, kernel_size []int64, stride []int64, padding []int64, ceil_mode bool, count_include_pad bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_avg_pool1d(c_tensors, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, if ceil_mode { 1 } else { 0 }, if count_include_pad { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_avg_pool2d(self Tensor, kernel_size []int64, stride []int64, padding []int64, ceil_mode bool, count_include_pad bool, divisor_override int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_avg_pool2d(c_tensors, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, if ceil_mode { 1 } else { 0 }, if count_include_pad { 1 } else { 0 }, divisor_override) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_avg_pool2d_backward(self Tensor, grad_output Tensor, kernel_size []int64, stride []int64, padding []int64, ceil_mode bool, count_include_pad bool, divisor_override int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_avg_pool2d_backward(c_tensors, grad_output.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, if ceil_mode { 1 } else { 0 }, if count_include_pad { 1 } else { 0 }, divisor_override) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_avg_pool2d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, kernel_size []int64, stride []int64, padding []int64, ceil_mode bool, count_include_pad bool, divisor_override int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_avg_pool2d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, if ceil_mode { 1 } else { 0 }, if count_include_pad { 1 } else { 0 }, divisor_override) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_avg_pool2d_out(self Tensor, out Tensor, kernel_size []int64, stride []int64, padding []int64, ceil_mode bool, count_include_pad bool, divisor_override int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_avg_pool2d_out(c_tensors, out.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, if ceil_mode { 1 } else { 0 }, if count_include_pad { 1 } else { 0 }, divisor_override) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_avg_pool3d(self Tensor, kernel_size []int64, stride []int64, padding []int64, ceil_mode bool, count_include_pad bool, divisor_override int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_avg_pool3d(c_tensors, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, if ceil_mode { 1 } else { 0 }, if count_include_pad { 1 } else { 0 }, divisor_override) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_avg_pool3d_backward(self Tensor, grad_output Tensor, kernel_size []int64, stride []int64, padding []int64, ceil_mode bool, count_include_pad bool, divisor_override int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_avg_pool3d_backward(c_tensors, grad_output.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, if ceil_mode { 1 } else { 0 }, if count_include_pad { 1 } else { 0 }, divisor_override) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_avg_pool3d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, kernel_size []int64, stride []int64, padding []int64, ceil_mode bool, count_include_pad bool, divisor_override int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_avg_pool3d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, if ceil_mode { 1 } else { 0 }, if count_include_pad { 1 } else { 0 }, divisor_override) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_avg_pool3d_out(self Tensor, out Tensor, kernel_size []int64, stride []int64, padding []int64, ceil_mode bool, count_include_pad bool, divisor_override int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_avg_pool3d_out(c_tensors, out.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, if ceil_mode { 1 } else { 0 }, if count_include_pad { 1 } else { 0 }, divisor_override) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_baddbmm(self Tensor, batch1 Tensor, batch2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_baddbmm(c_tensors, self.c_tensor, batch1.c_tensor, batch2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_baddbmm_(self Tensor, batch1 Tensor, batch2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_baddbmm_(c_tensors, self.c_tensor, batch1.c_tensor, batch2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_baddbmm_out(self Tensor, out Tensor, batch1 Tensor, batch2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_baddbmm_out(c_tensors, out.c_tensor, self.c_tensor, batch1.c_tensor, batch2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bartlett_window(self Tensor, window_length int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bartlett_window(c_tensors, window_length, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bartlett_window1(self Tensor, window_length int64, periodic bool, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bartlett_window1(c_tensors, window_length, if periodic { 1 } else { 0 }, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_batch_normTensor(self Tensor, input Tensor, weight TensorOption, bias TensorOption, running_mean TensorOption, running_var TensorOption, training bool, momentum float64, eps float64, cudnn_enabled bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_batch_norm(c_tensors, input.c_tensor, weight.c_tensor), bias.c_tensor), running_mean.c_tensor), running_var.c_tensor), if training { 1 } else { 0 }, momentum, eps, if cudnn_enabled { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_batch_norm_backward_elemtTensor(self Tensor, grad_out Tensor, input Tensor, mean Tensor, invstd Tensor, weight TensorOption, mean_dy Tensor, mean_dy_xmu Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_batch_norm_backward_elemt(c_tensors, grad_out.c_tensor, input.c_tensor, mean.c_tensor, invstd.c_tensor, weight.c_tensor), mean_dy.c_tensor, mean_dy_xmu.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_batch_norm_backward_reduceTensor(self Tensor, grad_out Tensor, input Tensor, mean Tensor, invstd Tensor, weight TensorOption, input_g bool, weight_g bool, bias_g bool)(error, (Tensor, Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 4) 
    unsafe_torch_err({ 
        atg_batch_norm_backward_reduce(c_tensors, grad_out.c_tensor, input.c_tensor, mean.c_tensor, invstd.c_tensor, weight.c_tensor), if input_g { 1 } else { 0 }, if weight_g { 1 } else { 0 }, if bias_g { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }, Tensor { C_tensor: c_tensors[3] }) 
} 

func f_batch_norm_elemtTensor(self Tensor, input Tensor, weight TensorOption, bias TensorOption, mean Tensor, invstd Tensor, eps float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_batch_norm_elemt(c_tensors, input.c_tensor, weight.c_tensor), bias.c_tensor), mean.c_tensor, invstd.c_tensor, eps) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_batch_norm_elemt_outTensor(self Tensor, out Tensor, input Tensor, weight TensorOption, bias TensorOption, mean Tensor, invstd Tensor, eps float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_batch_norm_elemt_out(c_tensors, out.c_tensor, input.c_tensor, weight.c_tensor), bias.c_tensor), mean.c_tensor, invstd.c_tensor, eps) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_batch_norm_gather_statsTensor(self Tensor, input Tensor, mean Tensor, invstd Tensor, running_mean TensorOption, running_var TensorOption, momentum float64, eps float64, count int64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_batch_norm_gather_stats(c_tensors, input.c_tensor, mean.c_tensor, invstd.c_tensor, running_mean.c_tensor), running_var.c_tensor), momentum, eps, count) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_batch_norm_gather_stats_with_countsTensor(self Tensor, input Tensor, mean Tensor, invstd Tensor, running_mean TensorOption, running_var TensorOption, momentum float64, eps float64, counts []int64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_batch_norm_gather_stats_with_counts(c_tensors, input.c_tensor, mean.c_tensor, invstd.c_tensor, running_mean.c_tensor), running_var.c_tensor), momentum, eps, counts.as_ptr(), counts.len() int32) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_batch_norm_stats(self Tensor, input Tensor, eps float64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_batch_norm_stats(c_tensors, input.c_tensor, eps) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_batch_norm_update_statsTensor(self Tensor, input Tensor, running_mean TensorOption, running_var TensorOption, momentum float64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_batch_norm_update_stats(c_tensors, input.c_tensor, running_mean.c_tensor), running_var.c_tensor), momentum) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_bernoulli(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bernoulli(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bernoulli1(self Tensor, p float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bernoulli1(c_tensors, self.c_tensor, p) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bernoulli_(self Tensor, p Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bernoulli_(c_tensors, self.c_tensor, p.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bernoulli_1(self Tensor, p float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bernoulli_1(c_tensors, self.c_tensor, p) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bernoulli_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bernoulli_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bilinearTensor(self Tensor, input1 Tensor, input2 Tensor, weight Tensor, bias TensorOption)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bilinear(c_tensors, input1.c_tensor, input2.c_tensor, weight.c_tensor, bias.c_tensor)) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_binary_cross_entropyTensor(self Tensor, target Tensor, weight TensorOption, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_binary_cross_entropy(c_tensors, self.c_tensor, target.c_tensor, weight.c_tensor), reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_binary_cross_entropy_backwardTensor(self Tensor, grad_output Tensor, target Tensor, weight TensorOption, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_binary_cross_entropy_backward(c_tensors, grad_output.c_tensor, self.c_tensor, target.c_tensor, weight.c_tensor), reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_binary_cross_entropy_backward_outTensor(self Tensor, grad_input Tensor, grad_output Tensor, target Tensor, weight TensorOption, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_binary_cross_entropy_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, target.c_tensor, weight.c_tensor), reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_binary_cross_entropy_outTensor(self Tensor, out Tensor, target Tensor, weight TensorOption, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_binary_cross_entropy_out(c_tensors, out.c_tensor, self.c_tensor, target.c_tensor, weight.c_tensor), reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_binary_cross_entropy_with_logitsTensor(self Tensor, target Tensor, weight TensorOption, pos_weight TensorOption, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_binary_cross_entropy_with_logits(c_tensors, self.c_tensor, target.c_tensor, weight.c_tensor), pos_weight.c_tensor), reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_binary_cross_entropy_with_logits_backwardTensor(self Tensor, grad_output Tensor, target Tensor, weight TensorOption, pos_weight TensorOption, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_binary_cross_entropy_with_logits_backward(c_tensors, grad_output.c_tensor, self.c_tensor, target.c_tensor, weight.c_tensor), pos_weight.c_tensor), reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bincountTensor(self Tensor, weights TensorOption, minlength int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bincount(c_tensors, self.c_tensor, weights.c_tensor), minlength) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_andScalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_and(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_and1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_and1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_and_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_and_(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_and_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_and_1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_and_out(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_and_out(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_and_out1Scalar(self Tensor, out Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_and_out1(c_tensors, out.c_tensor, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_not(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_not(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_not_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_not_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_not_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_not_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_orScalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_or(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_or1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_or1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_or_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_or_(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_or_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_or_1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_or_out(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_or_out(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_or_out1Scalar(self Tensor, out Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_or_out1(c_tensors, out.c_tensor, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_xorScalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_xor(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_xor1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_xor1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_xor_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_xor_(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_xor_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_xor_1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_xor_out(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_xor_out(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bitwise_xor_out1Scalar(self Tensor, out Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bitwise_xor_out1(c_tensors, out.c_tensor, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_blackman_window(self Tensor, window_length int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_blackman_window(c_tensors, window_length, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_blackman_window1(self Tensor, window_length int64, periodic bool, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_blackman_window1(c_tensors, window_length, if periodic { 1 } else { 0 }, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bmm(self Tensor, mat2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bmm(c_tensors, self.c_tensor, mat2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_bmm_out(self Tensor, out Tensor, mat2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_bmm_out(c_tensors, out.c_tensor, self.c_tensor, mat2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_broadcast_tensorsTensor(self Tensor, tensors []Tensor)(error, []Tensor) { 
        c_tensors := unsafe_torch_err!({atg_broadcast_tensors(ptr_list(tensors).as_ptr(), tensors.len() int32)}) 
        var r__ []Tensor 
        i := 0 
        for { 
            c__ := unsafe{*c_tensors.add(i)} 
            if c__.is_null() { break } 
            r__ = append(r__, Tensor {C_tensor: c__}) 
            i += 1 
        } 
        return r__ 
} 

func f_cartesian_prodTensor(self Tensor, tensors []Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cartesian_prod(c_tensors, ptr_list(tensors).as_ptr(), tensors.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_catTensor(self Tensor, tensors []Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cat(c_tensors, ptr_list(tensors).as_ptr(), tensors.len() int32, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cat_outTensor(self Tensor, out Tensor, tensors []Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cat_out(c_tensors, out.c_tensor, ptr_list(tensors).as_ptr(), tensors.len() int32, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cauchy_(self Tensor, median float64, sigma float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cauchy_(c_tensors, self.c_tensor, median, sigma) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cdist(self Tensor, x1 Tensor, x2 Tensor, p float64, compute_mode int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cdist(c_tensors, x1.c_tensor, x2.c_tensor, p, compute_mode) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ceil(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ceil(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ceil_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ceil_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ceil_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ceil_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_celu(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_celu(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_celu_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_celu_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_chain_matmulTensor(self Tensor, matrices []Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_chain_matmul(c_tensors, ptr_list(matrices).as_ptr(), matrices.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cholesky(self Tensor, upper bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cholesky(c_tensors, self.c_tensor, if upper { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cholesky_inverse(self Tensor, upper bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cholesky_inverse(c_tensors, self.c_tensor, if upper { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cholesky_inverse_out(self Tensor, out Tensor, upper bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cholesky_inverse_out(c_tensors, out.c_tensor, self.c_tensor, if upper { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cholesky_out(self Tensor, out Tensor, upper bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cholesky_out(c_tensors, out.c_tensor, self.c_tensor, if upper { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cholesky_solve(self Tensor, input2 Tensor, upper bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cholesky_solve(c_tensors, self.c_tensor, input2.c_tensor, if upper { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cholesky_solve_out(self Tensor, out Tensor, input2 Tensor, upper bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cholesky_solve_out(c_tensors, out.c_tensor, self.c_tensor, input2.c_tensor, if upper { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_chunk(self Tensor, chunks int64, dim int64)(error, []Tensor) { 
        c_tensors := unsafe_torch_err!({atg_chunk(self.c_tensor, chunks, dim)}) 
        var r__ []Tensor 
        i := 0 
        for { 
            c__ := unsafe{*c_tensors.add(i)} 
            if c__.is_null() { break } 
            r__ = append(r__, Tensor {C_tensor: c__}) 
            i += 1 
        } 
        return r__ 
} 

func f_clampScalar(self Tensor, min Scalar, max Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_clamp(c_tensors, self.c_tensor, min.c_scalar, max.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_clamp_Scalar(self Tensor, min Scalar, max Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_clamp_(c_tensors, self.c_tensor, min.c_scalar, max.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_clamp_maxScalar(self Tensor, max Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_clamp_max(c_tensors, self.c_tensor, max.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_clamp_max_Scalar(self Tensor, max Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_clamp_max_(c_tensors, self.c_tensor, max.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_clamp_max_outScalar(self Tensor, out Tensor, max Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_clamp_max_out(c_tensors, out.c_tensor, self.c_tensor, max.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_clamp_minScalar(self Tensor, min Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_clamp_min(c_tensors, self.c_tensor, min.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_clamp_min_Scalar(self Tensor, min Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_clamp_min_(c_tensors, self.c_tensor, min.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_clamp_min_outScalar(self Tensor, out Tensor, min Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_clamp_min_out(c_tensors, out.c_tensor, self.c_tensor, min.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_clamp_outScalar(self Tensor, out Tensor, min Scalar, max Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_clamp_out(c_tensors, out.c_tensor, self.c_tensor, min.c_scalar, max.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_coalesce(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_coalesce(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_col2im(self Tensor, output_size []int64, kernel_size []int64, dilation []int64, padding []int64, stride []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_col2im(c_tensors, self.c_tensor, output_size.as_ptr(), output_size.len() int32, kernel_size.as_ptr(), kernel_size.len() int32, dilation.as_ptr(), dilation.len() int32, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_col2im_backward(self Tensor, grad_output Tensor, kernel_size []int64, dilation []int64, padding []int64, stride []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_col2im_backward(c_tensors, grad_output.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, dilation.as_ptr(), dilation.len() int32, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_col2im_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, kernel_size []int64, dilation []int64, padding []int64, stride []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_col2im_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, dilation.as_ptr(), dilation.len() int32, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_col2im_out(self Tensor, out Tensor, output_size []int64, kernel_size []int64, dilation []int64, padding []int64, stride []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_col2im_out(c_tensors, out.c_tensor, self.c_tensor, output_size.as_ptr(), output_size.len() int32, kernel_size.as_ptr(), kernel_size.len() int32, dilation.as_ptr(), dilation.len() int32, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_combinations(self Tensor, r int64, with_replacement bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_combinations(c_tensors, self.c_tensor, r, if with_replacement { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_conj(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_conj(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_conj_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_conj_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_constant_pad_nd(self Tensor, pad []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_constant_pad_nd(c_tensors, self.c_tensor, pad.as_ptr(), pad.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_contiguous(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_contiguous(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_conv1dTensor(self Tensor, input Tensor, weight Tensor, bias TensorOption, stride []int64, padding []int64, dilation []int64, groups int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_conv1d(c_tensors, input.c_tensor, weight.c_tensor, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, groups) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_conv2dTensor(self Tensor, input Tensor, weight Tensor, bias TensorOption, stride []int64, padding []int64, dilation []int64, groups int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_conv2d(c_tensors, input.c_tensor, weight.c_tensor, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, groups) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_conv3dTensor(self Tensor, input Tensor, weight Tensor, bias TensorOption, stride []int64, padding []int64, dilation []int64, groups int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_conv3d(c_tensors, input.c_tensor, weight.c_tensor, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, groups) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_conv_tbc(self Tensor, weight Tensor, bias Tensor, pad int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_conv_tbc(c_tensors, self.c_tensor, weight.c_tensor, bias.c_tensor, pad) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_conv_tbc_backward(self Tensor, input Tensor, weight Tensor, bias Tensor, pad int64)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg_conv_tbc_backward(c_tensors, self.c_tensor, input.c_tensor, weight.c_tensor, bias.c_tensor, pad) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_conv_transpose1dTensor(self Tensor, input Tensor, weight Tensor, bias TensorOption, stride []int64, padding []int64, output_padding []int64, groups int64, dilation []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_conv_transpose1d(c_tensors, input.c_tensor, weight.c_tensor, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, output_padding.as_ptr(), output_padding.len() int32, groups, dilation.as_ptr(), dilation.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_conv_transpose2dTensor(self Tensor, input Tensor, weight Tensor, bias TensorOption, stride []int64, padding []int64, output_padding []int64, groups int64, dilation []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_conv_transpose2d(c_tensors, input.c_tensor, weight.c_tensor, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, output_padding.as_ptr(), output_padding.len() int32, groups, dilation.as_ptr(), dilation.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_conv_transpose3dTensor(self Tensor, input Tensor, weight Tensor, bias TensorOption, stride []int64, padding []int64, output_padding []int64, groups int64, dilation []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_conv_transpose3d(c_tensors, input.c_tensor, weight.c_tensor, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, output_padding.as_ptr(), output_padding.len() int32, groups, dilation.as_ptr(), dilation.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_convolutionTensor(self Tensor, input Tensor, weight Tensor, bias TensorOption, stride []int64, padding []int64, dilation []int64, transposed bool, output_padding []int64, groups int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_convolution(c_tensors, input.c_tensor, weight.c_tensor, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if transposed { 1 } else { 0 }, output_padding.as_ptr(), output_padding.len() int32, groups) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_convolution_overrideableTensor(self Tensor, input Tensor, weight Tensor, bias TensorOption, stride []int64, padding []int64, dilation []int64, transposed bool, output_padding []int64, groups int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_convolution_overrideable(c_tensors, input.c_tensor, weight.c_tensor, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if transposed { 1 } else { 0 }, output_padding.as_ptr(), output_padding.len() int32, groups) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_copy_sparse_to_sparse_(self Tensor, src Tensor, non_blocking bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_copy_sparse_to_sparse_(c_tensors, self.c_tensor, src.c_tensor, if non_blocking { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cos(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cos(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cos_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cos_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cos_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cos_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cosh(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cosh(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cosh_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cosh_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cosh_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cosh_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cosine_embedding_loss(self Tensor, input1 Tensor, input2 Tensor, target Tensor, margin float64, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cosine_embedding_loss(c_tensors, input1.c_tensor, input2.c_tensor, target.c_tensor, margin, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cosine_similarity(self Tensor, x1 Tensor, x2 Tensor, dim int64, eps float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cosine_similarity(c_tensors, x1.c_tensor, x2.c_tensor, dim, eps) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cross(self Tensor, other Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cross(c_tensors, self.c_tensor, other.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cross_out(self Tensor, out Tensor, other Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cross_out(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ctc_loss(self Tensor, log_probs Tensor, targets Tensor, input_lengths []int64, target_lengths []int64, blank int64, reduction int64, zero_infinity bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ctc_loss(c_tensors, log_probs.c_tensor, targets.c_tensor, input_lengths.as_ptr(), input_lengths.len() int32, target_lengths.as_ptr(), target_lengths.len() int32, blank, reduction.to_int(), if zero_infinity { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ctc_loss1(self Tensor, log_probs Tensor, targets Tensor, input_lengths Tensor, target_lengths Tensor, blank int64, reduction int64, zero_infinity bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ctc_loss1(c_tensors, log_probs.c_tensor, targets.c_tensor, input_lengths.c_tensor, target_lengths.c_tensor, blank, reduction.to_int(), if zero_infinity { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cudnn_affine_grid_generator(self Tensor, theta Tensor, n int64, c int64, h int64, w int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cudnn_affine_grid_generator(c_tensors, theta.c_tensor, n, c, h, w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cudnn_affine_grid_generator_backward(self Tensor, grad Tensor, n int64, c int64, h int64, w int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cudnn_affine_grid_generator_backward(c_tensors, grad.c_tensor, n, c, h, w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cudnn_batch_normTensor(self Tensor, input Tensor, weight Tensor, bias TensorOption, running_mean TensorOption, running_var TensorOption, training bool, exponential_average_factor float64, epsilon float64)(error, (Tensor, Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 4) 
    unsafe_torch_err({ 
        atg_cudnn_batch_norm(c_tensors, input.c_tensor, weight.c_tensor, bias.c_tensor), running_mean.c_tensor), running_var.c_tensor), if training { 1 } else { 0 }, exponential_average_factor, epsilon) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }, Tensor { C_tensor: c_tensors[3] }) 
} 

func f_cudnn_batch_norm_backwardTensor(self Tensor, input Tensor, grad_output Tensor, weight Tensor, running_mean TensorOption, running_var TensorOption, save_mean TensorOption, save_var TensorOption, epsilon float64, reservespace Tensor)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg_cudnn_batch_norm_backward(c_tensors, input.c_tensor, grad_output.c_tensor, weight.c_tensor, running_mean.c_tensor), running_var.c_tensor), save_mean.c_tensor), save_var.c_tensor), epsilon, reservespace.c_tensor) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_cudnn_convolution(self Tensor, weight Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cudnn_convolution(c_tensors, self.c_tensor, weight.c_tensor, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cudnn_convolution1Tensor(self Tensor, weight Tensor, bias TensorOption, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cudnn_convolution1(c_tensors, self.c_tensor, weight.c_tensor, bias.c_tensor), padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cudnn_convolution_backward_input(self Tensor, self_size []int64, grad_output Tensor, weight Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cudnn_convolution_backward_input(c_tensors, self_size.as_ptr(), self_size.len() int32, grad_output.c_tensor, weight.c_tensor, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cudnn_convolution_backward_weight(self Tensor, weight_size []int64, grad_output Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cudnn_convolution_backward_weight(c_tensors, weight_size.as_ptr(), weight_size.len() int32, grad_output.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cudnn_convolution_transpose(self Tensor, weight Tensor, padding []int64, output_padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cudnn_convolution_transpose(c_tensors, self.c_tensor, weight.c_tensor, padding.as_ptr(), padding.len() int32, output_padding.as_ptr(), output_padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cudnn_convolution_transpose1Tensor(self Tensor, weight Tensor, bias TensorOption, padding []int64, output_padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cudnn_convolution_transpose1(c_tensors, self.c_tensor, weight.c_tensor, bias.c_tensor), padding.as_ptr(), padding.len() int32, output_padding.as_ptr(), output_padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cudnn_convolution_transpose_backward_input(self Tensor, grad_output Tensor, weight Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cudnn_convolution_transpose_backward_input(c_tensors, grad_output.c_tensor, weight.c_tensor, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cudnn_convolution_transpose_backward_weight(self Tensor, weight_size []int64, grad_output Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cudnn_convolution_transpose_backward_weight(c_tensors, weight_size.as_ptr(), weight_size.len() int32, grad_output.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cudnn_grid_sampler(self Tensor, grid Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cudnn_grid_sampler(c_tensors, self.c_tensor, grid.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cudnn_grid_sampler_backward(self Tensor, grid Tensor, grad_output Tensor)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_cudnn_grid_sampler_backward(c_tensors, self.c_tensor, grid.c_tensor, grad_output.c_tensor) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_cummax(self Tensor, dim int64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_cummax(c_tensors, self.c_tensor, dim) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_cummax_out(self Tensor, values Tensor, indices Tensor, dim int64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_cummax_out(c_tensors, values.c_tensor, indices.c_tensor, self.c_tensor, dim) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_cummin(self Tensor, dim int64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_cummin(c_tensors, self.c_tensor, dim) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_cummin_out(self Tensor, values Tensor, indices Tensor, dim int64)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_cummin_out(c_tensors, values.c_tensor, indices.c_tensor, self.c_tensor, dim) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_cumprod(self Tensor, dim int64, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cumprod(c_tensors, self.c_tensor, dim, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cumprod_out(self Tensor, out Tensor, dim int64, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cumprod_out(c_tensors, out.c_tensor, self.c_tensor, dim, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cumsum(self Tensor, dim int64, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cumsum(c_tensors, self.c_tensor, dim, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_cumsum_out(self Tensor, out Tensor, dim int64, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_cumsum_out(c_tensors, out.c_tensor, self.c_tensor, dim, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_data(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_data(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_dequantize(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_dequantize(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_det(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_det(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_detach(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_detach(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_detach_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_detach_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_diag(self Tensor, diagonal int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_diag(c_tensors, self.c_tensor, diagonal) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_diag_embed(self Tensor, offset int64, dim1 int64, dim2 int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_diag_embed(c_tensors, self.c_tensor, offset, dim1, dim2) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_diag_out(self Tensor, out Tensor, diagonal int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_diag_out(c_tensors, out.c_tensor, self.c_tensor, diagonal) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_diagflat(self Tensor, offset int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_diagflat(c_tensors, self.c_tensor, offset) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_diagonal(self Tensor, offset int64, dim1 int64, dim2 int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_diagonal(c_tensors, self.c_tensor, offset, dim1, dim2) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_digamma(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_digamma(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_digamma_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_digamma_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_digamma_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_digamma_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_dist(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_dist(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_div(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_div(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_div1Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_div1(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_div_(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_div_(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_div_1Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_div_1(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_div_out(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_div_out(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_dot(self Tensor, tensor Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_dot(c_tensors, self.c_tensor, tensor.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_dot_out(self Tensor, out Tensor, tensor Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_dot_out(c_tensors, out.c_tensor, self.c_tensor, tensor.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_dropout(self Tensor, input Tensor, p float64, train bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_dropout(c_tensors, input.c_tensor, p, if train { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_dropout_(self Tensor, p float64, train bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_dropout_(c_tensors, self.c_tensor, p, if train { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_eig(self Tensor, eigenvectors bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_eig(c_tensors, self.c_tensor, if eigenvectors { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_eig_out(self Tensor, e Tensor, v Tensor, eigenvectors bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_eig_out(c_tensors, e.c_tensor, v.c_tensor, self.c_tensor, if eigenvectors { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_einsumTensor(self Tensor, equation string, tensors []Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_einsum(c_tensors, equation.as_ptr(), equation.len() int32, ptr_list(tensors).as_ptr(), tensors.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_elu(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_elu(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_elu_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_elu_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_elu_backwardScalar(self Tensor, grad_output Tensor, alpha Scalar, scale Scalar, input_scale Scalar, output Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_elu_backward(c_tensors, grad_output.c_tensor, alpha.c_scalar, scale.c_scalar, input_scale.c_scalar, output.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_elu_backward_outScalar(self Tensor, grad_input Tensor, grad_output Tensor, alpha Scalar, scale Scalar, input_scale Scalar, output Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_elu_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, alpha.c_scalar, scale.c_scalar, input_scale.c_scalar, output.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_elu_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_elu_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_embedding(self Tensor, weight Tensor, indices Tensor, padding_idx int64, scale_grad_by_freq bool, sparse bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_embedding(c_tensors, weight.c_tensor, indices.c_tensor, padding_idx, if scale_grad_by_freq { 1 } else { 0 }, if sparse { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_embedding_backward(self Tensor, grad Tensor, indices Tensor, num_weights int64, padding_idx int64, scale_grad_by_freq bool, sparse bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_embedding_backward(c_tensors, grad.c_tensor, indices.c_tensor, num_weights, padding_idx, if scale_grad_by_freq { 1 } else { 0 }, if sparse { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_embedding_bagTensor(self Tensor, weight Tensor, indices Tensor, offsets Tensor, scale_grad_by_freq bool, mode int64, sparse bool, per_sample_weights TensorOption, include_last_offset bool)(error, (Tensor, Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 4) 
    unsafe_torch_err({ 
        atg_embedding_bag(c_tensors, weight.c_tensor, indices.c_tensor, offsets.c_tensor, if scale_grad_by_freq { 1 } else { 0 }, mode, if sparse { 1 } else { 0 }, per_sample_weights.c_tensor), if include_last_offset { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }, Tensor { C_tensor: c_tensors[3] }) 
} 

func f_embedding_dense_backward(self Tensor, grad_output Tensor, indices Tensor, num_weights int64, padding_idx int64, scale_grad_by_freq bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_embedding_dense_backward(c_tensors, grad_output.c_tensor, indices.c_tensor, num_weights, padding_idx, if scale_grad_by_freq { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_embedding_renorm_(self Tensor, indices Tensor, max_norm float64, norm_type float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_embedding_renorm_(c_tensors, self.c_tensor, indices.c_tensor, max_norm, norm_type) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_embedding_sparse_backward(self Tensor, grad Tensor, indices Tensor, num_weights int64, padding_idx int64, scale_grad_by_freq bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_embedding_sparse_backward(c_tensors, grad.c_tensor, indices.c_tensor, num_weights, padding_idx, if scale_grad_by_freq { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_empty(self Tensor, size []int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_empty(c_tensors, size.as_ptr(), size.len() int32, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_empty_like(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_empty_like(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_empty_out(self Tensor, out Tensor, size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_empty_out(c_tensors, out.c_tensor, size.as_ptr(), size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_empty_strided(self Tensor, size []int64, stride []int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_empty_strided(c_tensors, size.as_ptr(), size.len() int32, stride.as_ptr(), stride.len() int32, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_eqScalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_eq(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_eq1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_eq1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_eq_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_eq_(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_eq_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_eq_1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_eq_outScalar(self Tensor, out Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_eq_out(c_tensors, out.c_tensor, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_eq_out1(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_eq_out1(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_erf(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_erf(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_erf_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_erf_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_erf_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_erf_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_erfc(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_erfc(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_erfc_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_erfc_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_erfc_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_erfc_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_erfinv(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_erfinv(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_erfinv_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_erfinv_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_erfinv_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_erfinv_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_exp(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_exp(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_exp_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_exp_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_exp_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_exp_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_expand(self Tensor, size []int64, implicit bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_expand(c_tensors, self.c_tensor, size.as_ptr(), size.len() int32, if implicit { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_expand_as(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_expand_as(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_expm1(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_expm1(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_expm1_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_expm1_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_expm1_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_expm1_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_exponential_(self Tensor, lambd float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_exponential_(c_tensors, self.c_tensor, lambd) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_eye(self Tensor, n int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_eye(c_tensors, n, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_eye1(self Tensor, n int64, m int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_eye1(c_tensors, n, m, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_eye_out(self Tensor, out Tensor, n int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_eye_out(c_tensors, out.c_tensor, n) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_eye_out1(self Tensor, out Tensor, n int64, m int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_eye_out1(c_tensors, out.c_tensor, n, m) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fake_quantize_per_channel_affine(self Tensor, scale Tensor, zero_point Tensor, axis int64, quant_min int64, quant_max int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fake_quantize_per_channel_affine(c_tensors, self.c_tensor, scale.c_tensor, zero_point.c_tensor, axis, quant_min, quant_max) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fake_quantize_per_channel_affine_backward(self Tensor, grad Tensor, scale Tensor, zero_point Tensor, axis int64, quant_min int64, quant_max int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fake_quantize_per_channel_affine_backward(c_tensors, grad.c_tensor, self.c_tensor, scale.c_tensor, zero_point.c_tensor, axis, quant_min, quant_max) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fake_quantize_per_tensor_affine(self Tensor, scale float64, zero_point int64, quant_min int64, quant_max int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fake_quantize_per_tensor_affine(c_tensors, self.c_tensor, scale, zero_point, quant_min, quant_max) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fake_quantize_per_tensor_affine_backward(self Tensor, grad Tensor, scale float64, zero_point int64, quant_min int64, quant_max int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fake_quantize_per_tensor_affine_backward(c_tensors, grad.c_tensor, self.c_tensor, scale, zero_point, quant_min, quant_max) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fbgemm_linear_fp16_weight(self Tensor, input Tensor, packed_weight Tensor, bias Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fbgemm_linear_fp16_weight(c_tensors, input.c_tensor, packed_weight.c_tensor, bias.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fbgemm_linear_fp16_weight_fp32_activation(self Tensor, input Tensor, packed_weight Tensor, bias Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fbgemm_linear_fp16_weight_fp32_activation(c_tensors, input.c_tensor, packed_weight.c_tensor, bias.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fbgemm_linear_int8_weightScalar(self Tensor, input Tensor, weight Tensor, packed Tensor, col_offsets Tensor, weight_scale Scalar, weight_zero_point Scalar, bias Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fbgemm_linear_int8_weight(c_tensors, input.c_tensor, weight.c_tensor, packed.c_tensor, col_offsets.c_tensor, weight_scale.c_scalar, weight_zero_point.c_scalar, bias.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fbgemm_linear_int8_weight_fp32_activationScalar(self Tensor, input Tensor, weight Tensor, packed Tensor, col_offsets Tensor, weight_scale Scalar, weight_zero_point Scalar, bias Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fbgemm_linear_int8_weight_fp32_activation(c_tensors, input.c_tensor, weight.c_tensor, packed.c_tensor, col_offsets.c_tensor, weight_scale.c_scalar, weight_zero_point.c_scalar, bias.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fbgemm_pack_gemm_matrix_fp16(self Tensor, input Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fbgemm_pack_gemm_matrix_fp16(c_tensors, input.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fbgemm_pack_quantized_matrix(self Tensor, input Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fbgemm_pack_quantized_matrix(c_tensors, input.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fbgemm_pack_quantized_matrix1(self Tensor, input Tensor, k int64, n int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fbgemm_pack_quantized_matrix1(c_tensors, input.c_tensor, k, n) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_feature_alpha_dropout(self Tensor, input Tensor, p float64, train bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_feature_alpha_dropout(c_tensors, input.c_tensor, p, if train { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_feature_alpha_dropout_(self Tensor, p float64, train bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_feature_alpha_dropout_(c_tensors, self.c_tensor, p, if train { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_feature_dropout(self Tensor, input Tensor, p float64, train bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_feature_dropout(c_tensors, input.c_tensor, p, if train { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_feature_dropout_(self Tensor, p float64, train bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_feature_dropout_(c_tensors, self.c_tensor, p, if train { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fft(self Tensor, signal_ndim int64, normalized bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fft(c_tensors, self.c_tensor, signal_ndim, if normalized { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fill_Scalar(self Tensor, value Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fill_(c_tensors, self.c_tensor, value.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fill_1(self Tensor, value Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fill_1(c_tensors, self.c_tensor, value.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fill_diagonal_Scalar(self Tensor, fill_value Scalar, wrap bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fill_diagonal_(c_tensors, self.c_tensor, fill_value.c_scalar, if wrap { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_flatten(self Tensor, start_dim int64, end_dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_flatten(c_tensors, self.c_tensor, start_dim, end_dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_flip(self Tensor, dims []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_flip(c_tensors, self.c_tensor, dims.as_ptr(), dims.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_floor(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_floor(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_floor_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_floor_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_floor_divide(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_floor_divide(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_floor_divide1Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_floor_divide1(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_floor_divide_(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_floor_divide_(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_floor_divide_1Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_floor_divide_1(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_floor_divide_out(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_floor_divide_out(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_floor_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_floor_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fmodScalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fmod(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fmod1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fmod1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fmod_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fmod_(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fmod_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fmod_1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fmod_outScalar(self Tensor, out Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fmod_out(c_tensors, out.c_tensor, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fmod_out1(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fmod_out1(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_frac(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_frac(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_frac_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_frac_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_frac_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_frac_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fractional_max_pool2d(self Tensor, kernel_size []int64, output_size []int64, random_samples Tensor)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_fractional_max_pool2d(c_tensors, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, output_size.as_ptr(), output_size.len() int32, random_samples.c_tensor) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_fractional_max_pool2d_backward(self Tensor, grad_output Tensor, kernel_size []int64, output_size []int64, indices Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fractional_max_pool2d_backward(c_tensors, grad_output.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, output_size.as_ptr(), output_size.len() int32, indices.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fractional_max_pool2d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, kernel_size []int64, output_size []int64, indices Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fractional_max_pool2d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, output_size.as_ptr(), output_size.len() int32, indices.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fractional_max_pool2d_out(self Tensor, output Tensor, indices Tensor, kernel_size []int64, output_size []int64, random_samples Tensor)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_fractional_max_pool2d_out(c_tensors, output.c_tensor, indices.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, output_size.as_ptr(), output_size.len() int32, random_samples.c_tensor) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_fractional_max_pool3d(self Tensor, kernel_size []int64, output_size []int64, random_samples Tensor)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_fractional_max_pool3d(c_tensors, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, output_size.as_ptr(), output_size.len() int32, random_samples.c_tensor) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_fractional_max_pool3d_backward(self Tensor, grad_output Tensor, kernel_size []int64, output_size []int64, indices Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fractional_max_pool3d_backward(c_tensors, grad_output.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, output_size.as_ptr(), output_size.len() int32, indices.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fractional_max_pool3d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, kernel_size []int64, output_size []int64, indices Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_fractional_max_pool3d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, output_size.as_ptr(), output_size.len() int32, indices.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fractional_max_pool3d_out(self Tensor, output Tensor, indices Tensor, kernel_size []int64, output_size []int64, random_samples Tensor)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_fractional_max_pool3d_out(c_tensors, output.c_tensor, indices.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, output_size.as_ptr(), output_size.len() int32, random_samples.c_tensor) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_frobenius_norm(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_frobenius_norm(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_frobenius_norm1(self Tensor, dim []int64, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_frobenius_norm1(c_tensors, self.c_tensor, dim.as_ptr(), dim.len() int32, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_frobenius_norm_out(self Tensor, out Tensor, dim []int64, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_frobenius_norm_out(c_tensors, out.c_tensor, self.c_tensor, dim.as_ptr(), dim.len() int32, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_from_file(self Tensor, filename string, shared bool, size int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_from_file(c_tensors, filename.as_ptr(), filename.len() int32, if shared { 1 } else { 0 }, size, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_fullScalar(self Tensor, size []int64, fill_value Scalar, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_full(c_tensors, size.as_ptr(), size.len() int32, fill_value.c_scalar, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_full_likeScalar(self Tensor, fill_value Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_full_like(c_tensors, self.c_tensor, fill_value.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_full_outScalar(self Tensor, out Tensor, size []int64, fill_value Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_full_out(c_tensors, out.c_tensor, size.as_ptr(), size.len() int32, fill_value.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_gather(self Tensor, dim int64, index Tensor, sparse_grad bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_gather(c_tensors, self.c_tensor, dim, index.c_tensor, if sparse_grad { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_gather_out(self Tensor, out Tensor, dim int64, index Tensor, sparse_grad bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_gather_out(c_tensors, out.c_tensor, self.c_tensor, dim, index.c_tensor, if sparse_grad { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_geScalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ge(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ge1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ge1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ge_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ge_(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ge_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ge_1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ge_outScalar(self Tensor, out Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ge_out(c_tensors, out.c_tensor, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ge_out1(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ge_out1(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_gelu(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_gelu(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_gelu_backward(self Tensor, grad Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_gelu_backward(c_tensors, grad.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_geometric_(self Tensor, p float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_geometric_(c_tensors, self.c_tensor, p) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_geqrf(self Tensor, )(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_geqrf(c_tensors, self.c_tensor) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_geqrf_out(self Tensor, a Tensor, tau Tensor)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_geqrf_out(c_tensors, a.c_tensor, tau.c_tensor, self.c_tensor) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_ger(self Tensor, vec2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ger(c_tensors, self.c_tensor, vec2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ger_out(self Tensor, out Tensor, vec2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ger_out(c_tensors, out.c_tensor, self.c_tensor, vec2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_glu(self Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_glu(c_tensors, self.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_glu_backward(self Tensor, grad_output Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_glu_backward(c_tensors, grad_output.c_tensor, self.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_glu_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_glu_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_glu_out(self Tensor, out Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_glu_out(c_tensors, out.c_tensor, self.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_grad(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_grad(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_grid_sampler(self Tensor, input Tensor, grid Tensor, interpolation_mode int64, padding_mode int64, align_corners bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_grid_sampler(c_tensors, input.c_tensor, grid.c_tensor, interpolation_mode, padding_mode, if align_corners { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_grid_sampler_2d(self Tensor, input Tensor, grid Tensor, interpolation_mode int64, padding_mode int64, align_corners bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_grid_sampler_2d(c_tensors, input.c_tensor, grid.c_tensor, interpolation_mode, padding_mode, if align_corners { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_grid_sampler_2d_backward(self Tensor, grad_output Tensor, input Tensor, grid Tensor, interpolation_mode int64, padding_mode int64, align_corners bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_grid_sampler_2d_backward(c_tensors, grad_output.c_tensor, input.c_tensor, grid.c_tensor, interpolation_mode, padding_mode, if align_corners { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_grid_sampler_3d(self Tensor, input Tensor, grid Tensor, interpolation_mode int64, padding_mode int64, align_corners bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_grid_sampler_3d(c_tensors, input.c_tensor, grid.c_tensor, interpolation_mode, padding_mode, if align_corners { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_grid_sampler_3d_backward(self Tensor, grad_output Tensor, input Tensor, grid Tensor, interpolation_mode int64, padding_mode int64, align_corners bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_grid_sampler_3d_backward(c_tensors, grad_output.c_tensor, input.c_tensor, grid.c_tensor, interpolation_mode, padding_mode, if align_corners { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_group_normTensor(self Tensor, input Tensor, num_groups int64, weight TensorOption, bias TensorOption, eps float64, cudnn_enabled bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_group_norm(c_tensors, input.c_tensor, num_groups, weight.c_tensor), bias.c_tensor), eps, if cudnn_enabled { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_gruTensor(self Tensor, input Tensor, hx Tensor, params []Tensor, has_biases bool, num_layers int64, dropout float64, train bool, bidirectional bool, batch_first bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_gru(c_tensors, input.c_tensor, hx.c_tensor, ptr_list(params).as_ptr(), params.len() int32, if has_biases { 1 } else { 0 }, num_layers, dropout, if train { 1 } else { 0 }, if bidirectional { 1 } else { 0 }, if batch_first { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_gru1Tensor(self Tensor, data Tensor, batch_sizes Tensor, hx Tensor, params []Tensor, has_biases bool, num_layers int64, dropout float64, train bool, bidirectional bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_gru1(c_tensors, data.c_tensor, batch_sizes.c_tensor, hx.c_tensor, ptr_list(params).as_ptr(), params.len() int32, if has_biases { 1 } else { 0 }, num_layers, dropout, if train { 1 } else { 0 }, if bidirectional { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_gru_cellTensor(self Tensor, input Tensor, hx Tensor, w_ih Tensor, w_hh Tensor, b_ih TensorOption, b_hh TensorOption)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_gru_cell(c_tensors, input.c_tensor, hx.c_tensor, w_ih.c_tensor, w_hh.c_tensor, b_ih.c_tensor), b_hh.c_tensor)) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_gtScalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_gt(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_gt1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_gt1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_gt_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_gt_(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_gt_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_gt_1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_gt_outScalar(self Tensor, out Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_gt_out(c_tensors, out.c_tensor, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_gt_out1(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_gt_out1(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hamming_window(self Tensor, window_length int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hamming_window(c_tensors, window_length, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hamming_window1(self Tensor, window_length int64, periodic bool, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hamming_window1(c_tensors, window_length, if periodic { 1 } else { 0 }, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hamming_window2(self Tensor, window_length int64, periodic bool, alpha float64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hamming_window2(c_tensors, window_length, if periodic { 1 } else { 0 }, alpha, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hamming_window3(self Tensor, window_length int64, periodic bool, alpha float64, beta float64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hamming_window3(c_tensors, window_length, if periodic { 1 } else { 0 }, alpha, beta, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hann_window(self Tensor, window_length int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hann_window(c_tensors, window_length, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hann_window1(self Tensor, window_length int64, periodic bool, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hann_window1(c_tensors, window_length, if periodic { 1 } else { 0 }, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hardshrink(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hardshrink(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hardshrink_backwardScalar(self Tensor, grad_out Tensor, lambd Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hardshrink_backward(c_tensors, grad_out.c_tensor, self.c_tensor, lambd.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hardsigmoid(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hardsigmoid(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hardsigmoid_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hardsigmoid_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hardsigmoid_backward(self Tensor, grad_output Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hardsigmoid_backward(c_tensors, grad_output.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hardsigmoid_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hardsigmoid_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hardtanh(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hardtanh(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hardtanh_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hardtanh_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hardtanh_backwardScalar(self Tensor, grad_output Tensor, min_val Scalar, max_val Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hardtanh_backward(c_tensors, grad_output.c_tensor, self.c_tensor, min_val.c_scalar, max_val.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hardtanh_backward_outScalar(self Tensor, grad_input Tensor, grad_output Tensor, min_val Scalar, max_val Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hardtanh_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, min_val.c_scalar, max_val.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hardtanh_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hardtanh_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hinge_embedding_loss(self Tensor, target Tensor, margin float64, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hinge_embedding_loss(c_tensors, self.c_tensor, target.c_tensor, margin, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_histc(self Tensor, bins int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_histc(c_tensors, self.c_tensor, bins) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_histc_out(self Tensor, out Tensor, bins int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_histc_out(c_tensors, out.c_tensor, self.c_tensor, bins) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hspmm(self Tensor, mat1 Tensor, mat2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hspmm(c_tensors, mat1.c_tensor, mat2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_hspmm_out(self Tensor, out Tensor, mat1 Tensor, mat2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_hspmm_out(c_tensors, out.c_tensor, mat1.c_tensor, mat2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ifft(self Tensor, signal_ndim int64, normalized bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ifft(c_tensors, self.c_tensor, signal_ndim, if normalized { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_im2col(self Tensor, kernel_size []int64, dilation []int64, padding []int64, stride []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_im2col(c_tensors, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, dilation.as_ptr(), dilation.len() int32, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_im2col_backward(self Tensor, grad_output Tensor, input_size []int64, kernel_size []int64, dilation []int64, padding []int64, stride []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_im2col_backward(c_tensors, grad_output.c_tensor, input_size.as_ptr(), input_size.len() int32, kernel_size.as_ptr(), kernel_size.len() int32, dilation.as_ptr(), dilation.len() int32, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_im2col_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, input_size []int64, kernel_size []int64, dilation []int64, padding []int64, stride []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_im2col_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, input_size.as_ptr(), input_size.len() int32, kernel_size.as_ptr(), kernel_size.len() int32, dilation.as_ptr(), dilation.len() int32, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_im2col_out(self Tensor, out Tensor, kernel_size []int64, dilation []int64, padding []int64, stride []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_im2col_out(c_tensors, out.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, dilation.as_ptr(), dilation.len() int32, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_imag(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_imag(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_indexTensor(self Tensor, indices []Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_index(c_tensors, self.c_tensor, ptr_list(indices).as_ptr(), indices.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_index_add(self Tensor, dim int64, index Tensor, source Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_index_add(c_tensors, self.c_tensor, dim, index.c_tensor, source.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_index_add_(self Tensor, dim int64, index Tensor, source Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_index_add_(c_tensors, self.c_tensor, dim, index.c_tensor, source.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_index_copy(self Tensor, dim int64, index Tensor, source Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_index_copy(c_tensors, self.c_tensor, dim, index.c_tensor, source.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_index_copy_(self Tensor, dim int64, index Tensor, source Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_index_copy_(c_tensors, self.c_tensor, dim, index.c_tensor, source.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_index_fillScalar(self Tensor, dim int64, index Tensor, value Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_index_fill(c_tensors, self.c_tensor, dim, index.c_tensor, value.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_index_fill1(self Tensor, dim int64, index Tensor, value Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_index_fill1(c_tensors, self.c_tensor, dim, index.c_tensor, value.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_index_fill_Scalar(self Tensor, dim int64, index Tensor, value Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_index_fill_(c_tensors, self.c_tensor, dim, index.c_tensor, value.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_index_fill_1(self Tensor, dim int64, index Tensor, value Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_index_fill_1(c_tensors, self.c_tensor, dim, index.c_tensor, value.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_index_putTensor(self Tensor, indices []Tensor, values Tensor, accumulate bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_index_put(c_tensors, self.c_tensor, ptr_list(indices).as_ptr(), indices.len() int32, values.c_tensor, if accumulate { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_index_put_Tensor(self Tensor, indices []Tensor, values Tensor, accumulate bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_index_put_(c_tensors, self.c_tensor, ptr_list(indices).as_ptr(), indices.len() int32, values.c_tensor, if accumulate { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_index_select(self Tensor, dim int64, index Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_index_select(c_tensors, self.c_tensor, dim, index.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_index_select_out(self Tensor, out Tensor, dim int64, index Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_index_select_out(c_tensors, out.c_tensor, self.c_tensor, dim, index.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_indices(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_indices(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_instance_normTensor(self Tensor, input Tensor, weight TensorOption, bias TensorOption, running_mean TensorOption, running_var TensorOption, use_input_stats bool, momentum float64, eps float64, cudnn_enabled bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_instance_norm(c_tensors, input.c_tensor, weight.c_tensor), bias.c_tensor), running_mean.c_tensor), running_var.c_tensor), if use_input_stats { 1 } else { 0 }, momentum, eps, if cudnn_enabled { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_int_repr(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_int_repr(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_inverse(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_inverse(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_inverse_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_inverse_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_irfft(self Tensor, signal_ndim int64, normalized bool, onesided bool, signal_sizes []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_irfft(c_tensors, self.c_tensor, signal_ndim, if normalized { 1 } else { 0 }, if onesided { 1 } else { 0 }, signal_sizes.as_ptr(), signal_sizes.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_isclose(self Tensor, other Tensor, rtol float64, atol float64, equal_nan bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_isclose(c_tensors, self.c_tensor, other.c_tensor, rtol, atol, if equal_nan { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_isfinite(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_isfinite(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_isinf(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_isinf(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_isnan(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_isnan(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_kl_div(self Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_kl_div(c_tensors, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_kl_div_backward(self Tensor, grad_output Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_kl_div_backward(c_tensors, grad_output.c_tensor, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_kthvalue(self Tensor, k int64, dim int64, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_kthvalue(c_tensors, self.c_tensor, k, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_kthvalue_out(self Tensor, values Tensor, indices Tensor, k int64, dim int64, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_kthvalue_out(c_tensors, values.c_tensor, indices.c_tensor, self.c_tensor, k, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_l1_loss(self Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_l1_loss(c_tensors, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_l1_loss_backward(self Tensor, grad_output Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_l1_loss_backward(c_tensors, grad_output.c_tensor, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_l1_loss_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_l1_loss_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_l1_loss_out(self Tensor, out Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_l1_loss_out(c_tensors, out.c_tensor, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_layer_normTensor(self Tensor, input Tensor, normalized_shape []int64, weight TensorOption, bias TensorOption, eps float64, cudnn_enable bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_layer_norm(c_tensors, input.c_tensor, normalized_shape.as_ptr(), normalized_shape.len() int32, weight.c_tensor), bias.c_tensor), eps, if cudnn_enable { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_leScalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_le(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_le1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_le1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_le_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_le_(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_le_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_le_1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_le_outScalar(self Tensor, out Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_le_out(c_tensors, out.c_tensor, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_le_out1(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_le_out1(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_leaky_relu(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_leaky_relu(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_leaky_relu_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_leaky_relu_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_leaky_relu_backwardScalar(self Tensor, grad_output Tensor, negative_slope Scalar, self_is_result bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_leaky_relu_backward(c_tensors, grad_output.c_tensor, self.c_tensor, negative_slope.c_scalar, if self_is_result { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_leaky_relu_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_leaky_relu_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_lerpScalar(self Tensor, end Tensor, weight Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_lerp(c_tensors, self.c_tensor, end.c_tensor, weight.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_lerp1(self Tensor, end Tensor, weight Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_lerp1(c_tensors, self.c_tensor, end.c_tensor, weight.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_lerp_Scalar(self Tensor, end Tensor, weight Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_lerp_(c_tensors, self.c_tensor, end.c_tensor, weight.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_lerp_1(self Tensor, end Tensor, weight Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_lerp_1(c_tensors, self.c_tensor, end.c_tensor, weight.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_lerp_outScalar(self Tensor, out Tensor, end Tensor, weight Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_lerp_out(c_tensors, out.c_tensor, self.c_tensor, end.c_tensor, weight.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_lerp_out1(self Tensor, out Tensor, end Tensor, weight Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_lerp_out1(c_tensors, out.c_tensor, self.c_tensor, end.c_tensor, weight.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_lgamma(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_lgamma(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_lgamma_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_lgamma_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_lgamma_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_lgamma_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_linearTensor(self Tensor, input Tensor, weight Tensor, bias TensorOption)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_linear(c_tensors, input.c_tensor, weight.c_tensor, bias.c_tensor)) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_linspaceScalar(self Tensor, start Scalar, end Scalar, steps int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_linspace(c_tensors, start.c_scalar, end.c_scalar, steps, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_linspace_outScalar(self Tensor, out Tensor, start Scalar, end Scalar, steps int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_linspace_out(c_tensors, out.c_tensor, start.c_scalar, end.c_scalar, steps) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log10(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log10(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log10_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log10_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log10_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log10_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log1p(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log1p(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log1p_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log1p_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log1p_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log1p_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log2(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log2(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log2_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log2_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log2_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log2_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log_normal_(self Tensor, mean float64, std float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log_normal_(c_tensors, self.c_tensor, mean, std) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log_sigmoid(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log_sigmoid(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log_sigmoid_backward(self Tensor, grad_output Tensor, buffer Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log_sigmoid_backward(c_tensors, grad_output.c_tensor, self.c_tensor, buffer.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log_sigmoid_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, buffer Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log_sigmoid_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, buffer.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log_sigmoid_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log_sigmoid_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_log_softmax(self Tensor, dim int64, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_log_softmax(c_tensors, self.c_tensor, dim, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_logdet(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_logdet(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_logical_and(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_logical_and(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_logical_and_(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_logical_and_(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_logical_and_out(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_logical_and_out(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_logical_not(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_logical_not(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_logical_not_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_logical_not_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_logical_not_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_logical_not_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_logical_or(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_logical_or(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_logical_or_(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_logical_or_(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_logical_or_out(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_logical_or_out(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_logical_xor(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_logical_xor(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_logical_xor_(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_logical_xor_(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_logical_xor_out(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_logical_xor_out(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_logspaceScalar(self Tensor, start Scalar, end Scalar, steps int64, base float64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_logspace(c_tensors, start.c_scalar, end.c_scalar, steps, base, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_logspace_outScalar(self Tensor, out Tensor, start Scalar, end Scalar, steps int64, base float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_logspace_out(c_tensors, out.c_tensor, start.c_scalar, end.c_scalar, steps, base) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_logsumexp(self Tensor, dim []int64, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_logsumexp(c_tensors, self.c_tensor, dim.as_ptr(), dim.len() int32, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_logsumexp_out(self Tensor, out Tensor, dim []int64, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_logsumexp_out(c_tensors, out.c_tensor, self.c_tensor, dim.as_ptr(), dim.len() int32, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_lstmTensor(self Tensor, input Tensor, hx []Tensor, params []Tensor, has_biases bool, num_layers int64, dropout float64, train bool, bidirectional bool, batch_first bool)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg_lstm(c_tensors, input.c_tensor, ptr_list(hx).as_ptr(), hx.len() int32, ptr_list(params).as_ptr(), params.len() int32, if has_biases { 1 } else { 0 }, num_layers, dropout, if train { 1 } else { 0 }, if bidirectional { 1 } else { 0 }, if batch_first { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_lstm1Tensor(self Tensor, data Tensor, batch_sizes Tensor, hx []Tensor, params []Tensor, has_biases bool, num_layers int64, dropout float64, train bool, bidirectional bool)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg_lstm1(c_tensors, data.c_tensor, batch_sizes.c_tensor, ptr_list(hx).as_ptr(), hx.len() int32, ptr_list(params).as_ptr(), params.len() int32, if has_biases { 1 } else { 0 }, num_layers, dropout, if train { 1 } else { 0 }, if bidirectional { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_lstm_cellTensor(self Tensor, input Tensor, hx []Tensor, w_ih Tensor, w_hh Tensor, b_ih TensorOption, b_hh TensorOption)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_lstm_cell(c_tensors, input.c_tensor, ptr_list(hx).as_ptr(), hx.len() int32, w_ih.c_tensor, w_hh.c_tensor, b_ih.c_tensor), b_hh.c_tensor)) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_lstsq(self Tensor, a Tensor)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_lstsq(c_tensors, self.c_tensor, a.c_tensor) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_lstsq_out(self Tensor, x Tensor, qr Tensor, a Tensor)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_lstsq_out(c_tensors, x.c_tensor, qr.c_tensor, self.c_tensor, a.c_tensor) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_ltScalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_lt(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_lt1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_lt1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_lt_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_lt_(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_lt_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_lt_1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_lt_outScalar(self Tensor, out Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_lt_out(c_tensors, out.c_tensor, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_lt_out1(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_lt_out1(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_lu_solve(self Tensor, lu_data Tensor, lu_pivots Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_lu_solve(c_tensors, self.c_tensor, lu_data.c_tensor, lu_pivots.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_lu_solve_out(self Tensor, out Tensor, lu_data Tensor, lu_pivots Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_lu_solve_out(c_tensors, out.c_tensor, self.c_tensor, lu_data.c_tensor, lu_pivots.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_margin_ranking_loss(self Tensor, input1 Tensor, input2 Tensor, target Tensor, margin float64, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_margin_ranking_loss(c_tensors, input1.c_tensor, input2.c_tensor, target.c_tensor, margin, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_masked_fillScalar(self Tensor, mask Tensor, value Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_masked_fill(c_tensors, self.c_tensor, mask.c_tensor, value.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_masked_fill1(self Tensor, mask Tensor, value Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_masked_fill1(c_tensors, self.c_tensor, mask.c_tensor, value.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_masked_fill_Scalar(self Tensor, mask Tensor, value Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_masked_fill_(c_tensors, self.c_tensor, mask.c_tensor, value.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_masked_fill_1(self Tensor, mask Tensor, value Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_masked_fill_1(c_tensors, self.c_tensor, mask.c_tensor, value.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_masked_scatter(self Tensor, mask Tensor, source Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_masked_scatter(c_tensors, self.c_tensor, mask.c_tensor, source.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_masked_scatter_(self Tensor, mask Tensor, source Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_masked_scatter_(c_tensors, self.c_tensor, mask.c_tensor, source.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_masked_select(self Tensor, mask Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_masked_select(c_tensors, self.c_tensor, mask.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_masked_select_out(self Tensor, out Tensor, mask Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_masked_select_out(c_tensors, out.c_tensor, self.c_tensor, mask.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_matmul(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_matmul(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_matmul_out(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_matmul_out(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_matrix_power(self Tensor, n int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_matrix_power(c_tensors, self.c_tensor, n) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_matrix_rank(self Tensor, symmetric bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_matrix_rank(c_tensors, self.c_tensor, if symmetric { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_matrix_rank1(self Tensor, tol float64, symmetric bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_matrix_rank1(c_tensors, self.c_tensor, tol, if symmetric { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max2(self Tensor, dim int64, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_max2(c_tensors, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_max_out(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max_out(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max_out1(self Tensor, max Tensor, max_values Tensor, dim int64, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_max_out1(c_tensors, max.c_tensor, max_values.c_tensor, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_max_pool1d(self Tensor, kernel_size []int64, stride []int64, padding []int64, dilation []int64, ceil_mode bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max_pool1d(c_tensors, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if ceil_mode { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max_pool1d_with_indices(self Tensor, kernel_size []int64, stride []int64, padding []int64, dilation []int64, ceil_mode bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_max_pool1d_with_indices(c_tensors, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if ceil_mode { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_max_pool2d(self Tensor, kernel_size []int64, stride []int64, padding []int64, dilation []int64, ceil_mode bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max_pool2d(c_tensors, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if ceil_mode { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max_pool2d_with_indices(self Tensor, kernel_size []int64, stride []int64, padding []int64, dilation []int64, ceil_mode bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_max_pool2d_with_indices(c_tensors, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if ceil_mode { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_max_pool2d_with_indices_backward(self Tensor, grad_output Tensor, kernel_size []int64, stride []int64, padding []int64, dilation []int64, ceil_mode bool, indices Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max_pool2d_with_indices_backward(c_tensors, grad_output.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if ceil_mode { 1 } else { 0 }, indices.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max_pool2d_with_indices_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, kernel_size []int64, stride []int64, padding []int64, dilation []int64, ceil_mode bool, indices Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max_pool2d_with_indices_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if ceil_mode { 1 } else { 0 }, indices.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max_pool2d_with_indices_out(self Tensor, out Tensor, indices Tensor, kernel_size []int64, stride []int64, padding []int64, dilation []int64, ceil_mode bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_max_pool2d_with_indices_out(c_tensors, out.c_tensor, indices.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if ceil_mode { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_max_pool3d(self Tensor, kernel_size []int64, stride []int64, padding []int64, dilation []int64, ceil_mode bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max_pool3d(c_tensors, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if ceil_mode { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max_pool3d_with_indices(self Tensor, kernel_size []int64, stride []int64, padding []int64, dilation []int64, ceil_mode bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_max_pool3d_with_indices(c_tensors, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if ceil_mode { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_max_pool3d_with_indices_backward(self Tensor, grad_output Tensor, kernel_size []int64, stride []int64, padding []int64, dilation []int64, ceil_mode bool, indices Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max_pool3d_with_indices_backward(c_tensors, grad_output.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if ceil_mode { 1 } else { 0 }, indices.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max_pool3d_with_indices_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, kernel_size []int64, stride []int64, padding []int64, dilation []int64, ceil_mode bool, indices Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max_pool3d_with_indices_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if ceil_mode { 1 } else { 0 }, indices.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max_pool3d_with_indices_out(self Tensor, out Tensor, indices Tensor, kernel_size []int64, stride []int64, padding []int64, dilation []int64, ceil_mode bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_max_pool3d_with_indices_out(c_tensors, out.c_tensor, indices.c_tensor, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if ceil_mode { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_max_unpool2d(self Tensor, indices Tensor, output_size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max_unpool2d(c_tensors, self.c_tensor, indices.c_tensor, output_size.as_ptr(), output_size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max_unpool2d_backward(self Tensor, grad_output Tensor, indices Tensor, output_size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max_unpool2d_backward(c_tensors, grad_output.c_tensor, self.c_tensor, indices.c_tensor, output_size.as_ptr(), output_size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max_unpool2d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, indices Tensor, output_size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max_unpool2d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, indices.c_tensor, output_size.as_ptr(), output_size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max_unpool2d_out(self Tensor, out Tensor, indices Tensor, output_size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max_unpool2d_out(c_tensors, out.c_tensor, self.c_tensor, indices.c_tensor, output_size.as_ptr(), output_size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max_unpool3d(self Tensor, indices Tensor, output_size []int64, stride []int64, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max_unpool3d(c_tensors, self.c_tensor, indices.c_tensor, output_size.as_ptr(), output_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max_unpool3d_backward(self Tensor, grad_output Tensor, indices Tensor, output_size []int64, stride []int64, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max_unpool3d_backward(c_tensors, grad_output.c_tensor, self.c_tensor, indices.c_tensor, output_size.as_ptr(), output_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max_unpool3d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, indices Tensor, output_size []int64, stride []int64, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max_unpool3d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, indices.c_tensor, output_size.as_ptr(), output_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max_unpool3d_out(self Tensor, out Tensor, indices Tensor, output_size []int64, stride []int64, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max_unpool3d_out(c_tensors, out.c_tensor, self.c_tensor, indices.c_tensor, output_size.as_ptr(), output_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_max_values(self Tensor, dim []int64, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_max_values(c_tensors, self.c_tensor, dim.as_ptr(), dim.len() int32, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mean(self Tensor, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mean(c_tensors, self.c_tensor, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mean1(self Tensor, dim []int64, keepdim bool, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mean1(c_tensors, self.c_tensor, dim.as_ptr(), dim.len() int32, if keepdim { 1 } else { 0 }, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mean_out(self Tensor, out Tensor, dim []int64, keepdim bool, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mean_out(c_tensors, out.c_tensor, self.c_tensor, dim.as_ptr(), dim.len() int32, if keepdim { 1 } else { 0 }, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_median(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_median(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_median1(self Tensor, dim int64, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_median1(c_tensors, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_median_out(self Tensor, values Tensor, indices Tensor, dim int64, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_median_out(c_tensors, values.c_tensor, indices.c_tensor, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_meshgridTensor(self Tensor, tensors []Tensor)(error, []Tensor) { 
        c_tensors := unsafe_torch_err!({atg_meshgrid(ptr_list(tensors).as_ptr(), tensors.len() int32)}) 
        var r__ []Tensor 
        i := 0 
        for { 
            c__ := unsafe{*c_tensors.add(i)} 
            if c__.is_null() { break } 
            r__ = append(r__, Tensor {C_tensor: c__}) 
            i += 1 
        } 
        return r__ 
} 

func f_min(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_min(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_min1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_min1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_min2(self Tensor, dim int64, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_min2(c_tensors, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_min_out(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_min_out(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_min_out1(self Tensor, min Tensor, min_indices Tensor, dim int64, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_min_out1(c_tensors, min.c_tensor, min_indices.c_tensor, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_min_values(self Tensor, dim []int64, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_min_values(c_tensors, self.c_tensor, dim.as_ptr(), dim.len() int32, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_miopen_batch_normTensor(self Tensor, input Tensor, weight Tensor, bias TensorOption, running_mean TensorOption, running_var TensorOption, training bool, exponential_average_factor float64, epsilon float64)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg_miopen_batch_norm(c_tensors, input.c_tensor, weight.c_tensor, bias.c_tensor), running_mean.c_tensor), running_var.c_tensor), if training { 1 } else { 0 }, exponential_average_factor, epsilon) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_miopen_batch_norm_backwardTensor(self Tensor, input Tensor, grad_output Tensor, weight Tensor, running_mean TensorOption, running_var TensorOption, save_mean TensorOption, save_var TensorOption, epsilon float64)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg_miopen_batch_norm_backward(c_tensors, input.c_tensor, grad_output.c_tensor, weight.c_tensor, running_mean.c_tensor), running_var.c_tensor), save_mean.c_tensor), save_var.c_tensor), epsilon) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_miopen_convolutionTensor(self Tensor, weight Tensor, bias TensorOption, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_miopen_convolution(c_tensors, self.c_tensor, weight.c_tensor, bias.c_tensor), padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_miopen_convolution_backward_bias(self Tensor, grad_output Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_miopen_convolution_backward_bias(c_tensors, grad_output.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_miopen_convolution_backward_input(self Tensor, self_size []int64, grad_output Tensor, weight Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_miopen_convolution_backward_input(c_tensors, self_size.as_ptr(), self_size.len() int32, grad_output.c_tensor, weight.c_tensor, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_miopen_convolution_backward_weight(self Tensor, weight_size []int64, grad_output Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_miopen_convolution_backward_weight(c_tensors, weight_size.as_ptr(), weight_size.len() int32, grad_output.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_miopen_convolution_transposeTensor(self Tensor, weight Tensor, bias TensorOption, padding []int64, output_padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_miopen_convolution_transpose(c_tensors, self.c_tensor, weight.c_tensor, bias.c_tensor), padding.as_ptr(), padding.len() int32, output_padding.as_ptr(), output_padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_miopen_convolution_transpose_backward_input(self Tensor, grad_output Tensor, weight Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_miopen_convolution_transpose_backward_input(c_tensors, grad_output.c_tensor, weight.c_tensor, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_miopen_convolution_transpose_backward_weight(self Tensor, weight_size []int64, grad_output Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_miopen_convolution_transpose_backward_weight(c_tensors, weight_size.as_ptr(), weight_size.len() int32, grad_output.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_miopen_depthwise_convolutionTensor(self Tensor, weight Tensor, bias TensorOption, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_miopen_depthwise_convolution(c_tensors, self.c_tensor, weight.c_tensor, bias.c_tensor), padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_miopen_depthwise_convolution_backward_input(self Tensor, self_size []int64, grad_output Tensor, weight Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_miopen_depthwise_convolution_backward_input(c_tensors, self_size.as_ptr(), self_size.len() int32, grad_output.c_tensor, weight.c_tensor, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_miopen_depthwise_convolution_backward_weight(self Tensor, weight_size []int64, grad_output Tensor, padding []int64, stride []int64, dilation []int64, groups int64, benchmark bool, deterministic bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_miopen_depthwise_convolution_backward_weight(c_tensors, weight_size.as_ptr(), weight_size.len() int32, grad_output.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if benchmark { 1 } else { 0 }, if deterministic { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_miopen_rnnTensor(self Tensor, input Tensor, weight []Tensor, weight_stride0 int64, hx Tensor, cx TensorOption, mode int64, hidden_size int64, num_layers int64, batch_first bool, dropout float64, train bool, bidirectional bool, batch_sizes []int64, dropout_state TensorOption)(error, (Tensor, Tensor, Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 5) 
    unsafe_torch_err({ 
        atg_miopen_rnn(c_tensors, input.c_tensor, ptr_list(weight).as_ptr(), weight.len() int32, weight_stride0, hx.c_tensor, cx.c_tensor), mode, hidden_size, num_layers, if batch_first { 1 } else { 0 }, dropout, if train { 1 } else { 0 }, if bidirectional { 1 } else { 0 }, batch_sizes.as_ptr(), batch_sizes.len() int32, dropout_state.c_tensor)) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }, Tensor { C_tensor: c_tensors[3] }, Tensor { C_tensor: c_tensors[4] }) 
} 

func f_mkldnn_adaptive_avg_pool2d(self Tensor, output_size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mkldnn_adaptive_avg_pool2d(c_tensors, self.c_tensor, output_size.as_ptr(), output_size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mkldnn_convolutionTensor(self Tensor, weight Tensor, bias TensorOption, padding []int64, stride []int64, dilation []int64, groups int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mkldnn_convolution(c_tensors, self.c_tensor, weight.c_tensor, bias.c_tensor), padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mkldnn_convolution_backward_input(self Tensor, self_size []int64, grad_output Tensor, weight Tensor, padding []int64, stride []int64, dilation []int64, groups int64, bias_defined bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mkldnn_convolution_backward_input(c_tensors, self_size.as_ptr(), self_size.len() int32, grad_output.c_tensor, weight.c_tensor, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if bias_defined { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mkldnn_convolution_backward_weights(self Tensor, weight_size []int64, grad_output Tensor, padding []int64, stride []int64, dilation []int64, groups int64, bias_defined bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_mkldnn_convolution_backward_weights(c_tensors, weight_size.as_ptr(), weight_size.len() int32, grad_output.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups, if bias_defined { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_mkldnn_linearTensor(self Tensor, input Tensor, weight Tensor, bias TensorOption)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mkldnn_linear(c_tensors, input.c_tensor, weight.c_tensor, bias.c_tensor)) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mkldnn_max_pool2d(self Tensor, kernel_size []int64, stride []int64, padding []int64, dilation []int64, ceil_mode bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mkldnn_max_pool2d(c_tensors, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if ceil_mode { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mkldnn_reorder_conv2d_weight(self Tensor, padding []int64, stride []int64, dilation []int64, groups int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mkldnn_reorder_conv2d_weight(c_tensors, self.c_tensor, padding.as_ptr(), padding.len() int32, stride.as_ptr(), stride.len() int32, dilation.as_ptr(), dilation.len() int32, groups) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mm(self Tensor, mat2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mm(c_tensors, self.c_tensor, mat2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mm_out(self Tensor, out Tensor, mat2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mm_out(c_tensors, out.c_tensor, self.c_tensor, mat2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mode(self Tensor, dim int64, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_mode(c_tensors, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_mode_out(self Tensor, values Tensor, indices Tensor, dim int64, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_mode_out(c_tensors, values.c_tensor, indices.c_tensor, self.c_tensor, dim, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_mse_loss(self Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mse_loss(c_tensors, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mse_loss_backward(self Tensor, grad_output Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mse_loss_backward(c_tensors, grad_output.c_tensor, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mse_loss_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mse_loss_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mse_loss_out(self Tensor, out Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mse_loss_out(c_tensors, out.c_tensor, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mul(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mul(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mul1Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mul1(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mul_(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mul_(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mul_1Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mul_1(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mul_out(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mul_out(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_multi_margin_loss_backwardTensor, Scalar(self Tensor, grad_output Tensor, target Tensor, p Scalar, margin Scalar, weight TensorOption, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_multi_margin_loss_backward(c_tensors, grad_output.c_tensor, self.c_tensor, target.c_tensor, p.c_scalar, margin.c_scalar, weight.c_tensor), reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_multi_margin_loss_backward_outTensor, Scalar(self Tensor, grad_input Tensor, grad_output Tensor, target Tensor, p Scalar, margin Scalar, weight TensorOption, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_multi_margin_loss_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, target.c_tensor, p.c_scalar, margin.c_scalar, weight.c_tensor), reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_multilabel_margin_loss(self Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_multilabel_margin_loss(c_tensors, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_multilabel_margin_loss_backward(self Tensor, grad_output Tensor, target Tensor, reduction int64, is_target Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_multilabel_margin_loss_backward(c_tensors, grad_output.c_tensor, self.c_tensor, target.c_tensor, reduction.to_int(), is_target.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_multilabel_margin_loss_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, target Tensor, reduction int64, is_target Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_multilabel_margin_loss_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, target.c_tensor, reduction.to_int(), is_target.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_multilabel_margin_loss_out(self Tensor, out Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_multilabel_margin_loss_out(c_tensors, out.c_tensor, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_multinomial(self Tensor, num_samples int64, replacement bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_multinomial(c_tensors, self.c_tensor, num_samples, if replacement { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_multinomial_out(self Tensor, out Tensor, num_samples int64, replacement bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_multinomial_out(c_tensors, out.c_tensor, self.c_tensor, num_samples, if replacement { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mv(self Tensor, vec Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mv(c_tensors, self.c_tensor, vec.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mv_out(self Tensor, out Tensor, vec Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mv_out(c_tensors, out.c_tensor, self.c_tensor, vec.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mvlgamma(self Tensor, p int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mvlgamma(c_tensors, self.c_tensor, p) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_mvlgamma_(self Tensor, p int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_mvlgamma_(c_tensors, self.c_tensor, p) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_narrow(self Tensor, dim int64, start int64, length int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_narrow(c_tensors, self.c_tensor, dim, start, length) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_narrow1(self Tensor, dim int64, start Tensor, length int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_narrow1(c_tensors, self.c_tensor, dim, start.c_tensor, length) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_narrow_copy(self Tensor, dim int64, start int64, length int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_narrow_copy(c_tensors, self.c_tensor, dim, start, length) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_native_batch_normTensor(self Tensor, input Tensor, weight TensorOption, bias TensorOption, running_mean TensorOption, running_var TensorOption, training bool, momentum float64, eps float64)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg_native_batch_norm(c_tensors, input.c_tensor, weight.c_tensor), bias.c_tensor), running_mean.c_tensor), running_var.c_tensor), if training { 1 } else { 0 }, momentum, eps) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_native_batch_norm_outTensor(self Tensor, out Tensor, save_mean Tensor, save_invstd Tensor, input Tensor, weight TensorOption, bias TensorOption, running_mean TensorOption, running_var TensorOption, training bool, momentum float64, eps float64)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg_native_batch_norm_out(c_tensors, out.c_tensor, save_mean.c_tensor, save_invstd.c_tensor, input.c_tensor, weight.c_tensor), bias.c_tensor), running_mean.c_tensor), running_var.c_tensor), if training { 1 } else { 0 }, momentum, eps) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_native_layer_normTensor(self Tensor, input Tensor, weight TensorOption, bias TensorOption, m int64, n int64, eps float64)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg_native_layer_norm(c_tensors, input.c_tensor, weight.c_tensor), bias.c_tensor), m, n, eps) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_native_norm(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_native_norm(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_neScalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ne(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ne1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ne1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ne_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ne_(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ne_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ne_1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ne_outScalar(self Tensor, out Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ne_out(c_tensors, out.c_tensor, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ne_out1(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ne_out1(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_neg(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_neg(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_neg_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_neg_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_neg_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_neg_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_new_empty(self Tensor, size []int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_new_empty(c_tensors, self.c_tensor, size.as_ptr(), size.len() int32, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_new_fullScalar(self Tensor, size []int64, fill_value Scalar, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_new_full(c_tensors, self.c_tensor, size.as_ptr(), size.len() int32, fill_value.c_scalar, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_new_zeros(self Tensor, size []int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_new_zeros(c_tensors, self.c_tensor, size.as_ptr(), size.len() int32, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_nll_lossTensor(self Tensor, target Tensor, weight TensorOption, reduction int64, ignore_index int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_nll_loss(c_tensors, self.c_tensor, target.c_tensor, weight.c_tensor), reduction.to_int(), ignore_index) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_nll_loss2dTensor(self Tensor, target Tensor, weight TensorOption, reduction int64, ignore_index int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_nll_loss2d(c_tensors, self.c_tensor, target.c_tensor, weight.c_tensor), reduction.to_int(), ignore_index) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_nll_loss2d_backwardTensor(self Tensor, grad_output Tensor, target Tensor, weight TensorOption, reduction int64, ignore_index int64, total_weight Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_nll_loss2d_backward(c_tensors, grad_output.c_tensor, self.c_tensor, target.c_tensor, weight.c_tensor), reduction.to_int(), ignore_index, total_weight.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_nll_loss2d_backward_outTensor(self Tensor, grad_input Tensor, grad_output Tensor, target Tensor, weight TensorOption, reduction int64, ignore_index int64, total_weight Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_nll_loss2d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, target.c_tensor, weight.c_tensor), reduction.to_int(), ignore_index, total_weight.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_nll_loss2d_outTensor(self Tensor, out Tensor, target Tensor, weight TensorOption, reduction int64, ignore_index int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_nll_loss2d_out(c_tensors, out.c_tensor, self.c_tensor, target.c_tensor, weight.c_tensor), reduction.to_int(), ignore_index) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_nll_loss_backwardTensor(self Tensor, grad_output Tensor, target Tensor, weight TensorOption, reduction int64, ignore_index int64, total_weight Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_nll_loss_backward(c_tensors, grad_output.c_tensor, self.c_tensor, target.c_tensor, weight.c_tensor), reduction.to_int(), ignore_index, total_weight.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_nll_loss_backward_outTensor(self Tensor, grad_input Tensor, grad_output Tensor, target Tensor, weight TensorOption, reduction int64, ignore_index int64, total_weight Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_nll_loss_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, target.c_tensor, weight.c_tensor), reduction.to_int(), ignore_index, total_weight.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_nll_loss_outTensor(self Tensor, out Tensor, target Tensor, weight TensorOption, reduction int64, ignore_index int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_nll_loss_out(c_tensors, out.c_tensor, self.c_tensor, target.c_tensor, weight.c_tensor), reduction.to_int(), ignore_index) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_nonzero(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_nonzero(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_nonzero_numpy(self Tensor, )(error, []Tensor) { 
        c_tensors := unsafe_torch_err!({atg_nonzero_numpy(self.c_tensor)}) 
        var r__ []Tensor 
        i := 0 
        for { 
            c__ := unsafe{*c_tensors.add(i)} 
            if c__.is_null() { break } 
            r__ = append(r__, Tensor {C_tensor: c__}) 
            i += 1 
        } 
        return r__ 
} 

func f_nonzero_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_nonzero_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_norm(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_norm(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_norm1Scalar(self Tensor, p Scalar, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_norm1(c_tensors, self.c_tensor, p.c_scalar, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_norm2Scalar(self Tensor, p Scalar, dim []int64, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_norm2(c_tensors, self.c_tensor, p.c_scalar, dim.as_ptr(), dim.len() int32, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_norm3Scalar(self Tensor, p Scalar, dim []int64, keepdim bool, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_norm3(c_tensors, self.c_tensor, p.c_scalar, dim.as_ptr(), dim.len() int32, if keepdim { 1 } else { 0 }, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_norm_except_dim(self Tensor, v Tensor, pow int64, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_norm_except_dim(c_tensors, v.c_tensor, pow, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_norm_outScalar(self Tensor, out Tensor, p Scalar, dim []int64, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_norm_out(c_tensors, out.c_tensor, self.c_tensor, p.c_scalar, dim.as_ptr(), dim.len() int32, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_norm_out1Scalar(self Tensor, out Tensor, p Scalar, dim []int64, keepdim bool, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_norm_out1(c_tensors, out.c_tensor, self.c_tensor, p.c_scalar, dim.as_ptr(), dim.len() int32, if keepdim { 1 } else { 0 }, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_normal_(self Tensor, mean float64, std float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_normal_(c_tensors, self.c_tensor, mean, std) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_normal_out(self Tensor, out Tensor, mean Tensor, std float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_normal_out(c_tensors, out.c_tensor, mean.c_tensor, std) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_normal_out1(self Tensor, out Tensor, mean float64, std Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_normal_out1(c_tensors, out.c_tensor, mean, std.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_normal_out2(self Tensor, out Tensor, mean Tensor, std Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_normal_out2(c_tensors, out.c_tensor, mean.c_tensor, std.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_normal_out3(self Tensor, out Tensor, mean float64, std float64, size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_normal_out3(c_tensors, out.c_tensor, mean, std, size.as_ptr(), size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_nuclear_norm(self Tensor, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_nuclear_norm(c_tensors, self.c_tensor, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_nuclear_norm1(self Tensor, dim []int64, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_nuclear_norm1(c_tensors, self.c_tensor, dim.as_ptr(), dim.len() int32, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_nuclear_norm_out(self Tensor, out Tensor, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_nuclear_norm_out(c_tensors, out.c_tensor, self.c_tensor, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_nuclear_norm_out1(self Tensor, out Tensor, dim []int64, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_nuclear_norm_out1(c_tensors, out.c_tensor, self.c_tensor, dim.as_ptr(), dim.len() int32, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_numpy_t(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_numpy_t(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_one_hot(self Tensor, num_classes int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_one_hot(c_tensors, self.c_tensor, num_classes) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ones(self Tensor, size []int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ones(c_tensors, size.as_ptr(), size.len() int32, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ones_like(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ones_like(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ones_out(self Tensor, out Tensor, size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ones_out(c_tensors, out.c_tensor, size.as_ptr(), size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_orgqr(self Tensor, input2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_orgqr(c_tensors, self.c_tensor, input2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_orgqr_out(self Tensor, out Tensor, input2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_orgqr_out(c_tensors, out.c_tensor, self.c_tensor, input2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ormqr(self Tensor, input2 Tensor, input3 Tensor, left bool, transpose bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ormqr(c_tensors, self.c_tensor, input2.c_tensor, input3.c_tensor, if left { 1 } else { 0 }, if transpose { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_ormqr_out(self Tensor, out Tensor, input2 Tensor, input3 Tensor, left bool, transpose bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_ormqr_out(c_tensors, out.c_tensor, self.c_tensor, input2.c_tensor, input3.c_tensor, if left { 1 } else { 0 }, if transpose { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_pairwise_distance(self Tensor, x1 Tensor, x2 Tensor, p float64, eps float64, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_pairwise_distance(c_tensors, x1.c_tensor, x2.c_tensor, p, eps, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_pdist(self Tensor, p float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_pdist(c_tensors, self.c_tensor, p) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_permute(self Tensor, dims []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_permute(c_tensors, self.c_tensor, dims.as_ptr(), dims.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_pin_memory(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_pin_memory(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_pinverse(self Tensor, rcond float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_pinverse(c_tensors, self.c_tensor, rcond) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_pixel_shuffle(self Tensor, upscale_factor int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_pixel_shuffle(c_tensors, self.c_tensor, upscale_factor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_poisson(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_poisson(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_poisson_nll_loss(self Tensor, input Tensor, target Tensor, log_input bool, full bool, eps float64, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_poisson_nll_loss(c_tensors, input.c_tensor, target.c_tensor, if log_input { 1 } else { 0 }, if full { 1 } else { 0 }, eps, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_polygamma(self Tensor, n int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_polygamma(c_tensors, n, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_polygamma_(self Tensor, n int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_polygamma_(c_tensors, self.c_tensor, n) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_polygamma_out(self Tensor, out Tensor, n int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_polygamma_out(c_tensors, out.c_tensor, n, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_powScalar(self Tensor, exponent Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_pow(c_tensors, self.c_tensor, exponent.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_pow1(self Tensor, exponent Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_pow1(c_tensors, self.c_tensor, exponent.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_pow2Scalar(self Tensor, self_scalar Scalar, exponent Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_pow2(c_tensors, self_scalar.c_scalar, exponent.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_pow_Scalar(self Tensor, exponent Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_pow_(c_tensors, self.c_tensor, exponent.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_pow_1(self Tensor, exponent Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_pow_1(c_tensors, self.c_tensor, exponent.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_pow_outScalar(self Tensor, out Tensor, exponent Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_pow_out(c_tensors, out.c_tensor, self.c_tensor, exponent.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_pow_out1(self Tensor, out Tensor, exponent Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_pow_out1(c_tensors, out.c_tensor, self.c_tensor, exponent.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_pow_out2Scalar(self Tensor, out Tensor, self_scalar Scalar, exponent Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_pow_out2(c_tensors, out.c_tensor, self_scalar.c_scalar, exponent.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_prelu(self Tensor, weight Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_prelu(c_tensors, self.c_tensor, weight.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_prelu_backward(self Tensor, grad_output Tensor, weight Tensor)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_prelu_backward(c_tensors, grad_output.c_tensor, self.c_tensor, weight.c_tensor) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_prod(self Tensor, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_prod(c_tensors, self.c_tensor, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_prod1(self Tensor, dim int64, keepdim bool, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_prod1(c_tensors, self.c_tensor, dim, if keepdim { 1 } else { 0 }, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_prod_out(self Tensor, out Tensor, dim int64, keepdim bool, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_prod_out(c_tensors, out.c_tensor, self.c_tensor, dim, if keepdim { 1 } else { 0 }, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_put_(self Tensor, index Tensor, source Tensor, accumulate bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_put_(c_tensors, self.c_tensor, index.c_tensor, source.c_tensor, if accumulate { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_q_per_channel_scales(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_q_per_channel_scales(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_q_per_channel_zero_points(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_q_per_channel_zero_points(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_qr(self Tensor, some bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_qr(c_tensors, self.c_tensor, if some { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_qr_out(self Tensor, q Tensor, r Tensor, some bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_qr_out(c_tensors, q.c_tensor, r.c_tensor, self.c_tensor, if some { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_quantize_per_channel(self Tensor, scales Tensor, zero_points Tensor, axis int64, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_quantize_per_channel(c_tensors, self.c_tensor, scales.c_tensor, zero_points.c_tensor, axis, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_quantize_per_tensor(self Tensor, scale float64, zero_point int64, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_quantize_per_tensor(c_tensors, self.c_tensor, scale, zero_point, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_quantized_batch_normTensor(self Tensor, input Tensor, weight TensorOption, bias TensorOption, mean Tensor, var Tensor, eps float64, output_scale float64, output_zero_point int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_quantized_batch_norm(c_tensors, input.c_tensor, weight.c_tensor), bias.c_tensor), mean.c_tensor, var.c_tensor, eps, output_scale, output_zero_point) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_quantized_gruTensor(self Tensor, input Tensor, hx Tensor, params []Tensor, has_biases bool, num_layers int64, dropout float64, train bool, bidirectional bool, batch_first bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_quantized_gru(c_tensors, input.c_tensor, hx.c_tensor, ptr_list(params).as_ptr(), params.len() int32, if has_biases { 1 } else { 0 }, num_layers, dropout, if train { 1 } else { 0 }, if bidirectional { 1 } else { 0 }, if batch_first { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_quantized_gru1Tensor(self Tensor, data Tensor, batch_sizes Tensor, hx Tensor, params []Tensor, has_biases bool, num_layers int64, dropout float64, train bool, bidirectional bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_quantized_gru1(c_tensors, data.c_tensor, batch_sizes.c_tensor, hx.c_tensor, ptr_list(params).as_ptr(), params.len() int32, if has_biases { 1 } else { 0 }, num_layers, dropout, if train { 1 } else { 0 }, if bidirectional { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_quantized_gru_cellScalar(self Tensor, input Tensor, hx Tensor, w_ih Tensor, w_hh Tensor, b_ih Tensor, b_hh Tensor, packed_ih Tensor, packed_hh Tensor, col_offsets_ih Tensor, col_offsets_hh Tensor, scale_ih Scalar, scale_hh Scalar, zero_point_ih Scalar, zero_point_hh Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_quantized_gru_cell(c_tensors, input.c_tensor, hx.c_tensor, w_ih.c_tensor, w_hh.c_tensor, b_ih.c_tensor, b_hh.c_tensor, packed_ih.c_tensor, packed_hh.c_tensor, col_offsets_ih.c_tensor, col_offsets_hh.c_tensor, scale_ih.c_scalar, scale_hh.c_scalar, zero_point_ih.c_scalar, zero_point_hh.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_quantized_lstmTensor(self Tensor, input Tensor, hx []Tensor, params []Tensor, has_biases bool, num_layers int64, dropout float64, train bool, bidirectional bool, batch_first bool, dtype Kind, use_dynamic bool)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg_quantized_lstm(c_tensors, input.c_tensor, ptr_list(hx).as_ptr(), hx.len() int32, ptr_list(params).as_ptr(), params.len() int32, if has_biases { 1 } else { 0 }, num_layers, dropout, if train { 1 } else { 0 }, if bidirectional { 1 } else { 0 }, if batch_first { 1 } else { 0 }, dtype.c_int(), if use_dynamic { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_quantized_lstm1Tensor(self Tensor, data Tensor, batch_sizes Tensor, hx []Tensor, params []Tensor, has_biases bool, num_layers int64, dropout float64, train bool, bidirectional bool, dtype Kind, use_dynamic bool)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg_quantized_lstm1(c_tensors, data.c_tensor, batch_sizes.c_tensor, ptr_list(hx).as_ptr(), hx.len() int32, ptr_list(params).as_ptr(), params.len() int32, if has_biases { 1 } else { 0 }, num_layers, dropout, if train { 1 } else { 0 }, if bidirectional { 1 } else { 0 }, dtype.c_int(), if use_dynamic { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_quantized_lstm_cellTensor, Scalar(self Tensor, input Tensor, hx []Tensor, w_ih Tensor, w_hh Tensor, b_ih Tensor, b_hh Tensor, packed_ih Tensor, packed_hh Tensor, col_offsets_ih Tensor, col_offsets_hh Tensor, scale_ih Scalar, scale_hh Scalar, zero_point_ih Scalar, zero_point_hh Scalar)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_quantized_lstm_cell(c_tensors, input.c_tensor, ptr_list(hx).as_ptr(), hx.len() int32, w_ih.c_tensor, w_hh.c_tensor, b_ih.c_tensor, b_hh.c_tensor, packed_ih.c_tensor, packed_hh.c_tensor, col_offsets_ih.c_tensor, col_offsets_hh.c_tensor, scale_ih.c_scalar, scale_hh.c_scalar, zero_point_ih.c_scalar, zero_point_hh.c_scalar) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_quantized_max_pool2d(self Tensor, kernel_size []int64, stride []int64, padding []int64, dilation []int64, ceil_mode bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_quantized_max_pool2d(c_tensors, self.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32, if ceil_mode { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_quantized_rnn_relu_cellScalar(self Tensor, input Tensor, hx Tensor, w_ih Tensor, w_hh Tensor, b_ih Tensor, b_hh Tensor, packed_ih Tensor, packed_hh Tensor, col_offsets_ih Tensor, col_offsets_hh Tensor, scale_ih Scalar, scale_hh Scalar, zero_point_ih Scalar, zero_point_hh Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_quantized_rnn_relu_cell(c_tensors, input.c_tensor, hx.c_tensor, w_ih.c_tensor, w_hh.c_tensor, b_ih.c_tensor, b_hh.c_tensor, packed_ih.c_tensor, packed_hh.c_tensor, col_offsets_ih.c_tensor, col_offsets_hh.c_tensor, scale_ih.c_scalar, scale_hh.c_scalar, zero_point_ih.c_scalar, zero_point_hh.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_quantized_rnn_tanh_cellScalar(self Tensor, input Tensor, hx Tensor, w_ih Tensor, w_hh Tensor, b_ih Tensor, b_hh Tensor, packed_ih Tensor, packed_hh Tensor, col_offsets_ih Tensor, col_offsets_hh Tensor, scale_ih Scalar, scale_hh Scalar, zero_point_ih Scalar, zero_point_hh Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_quantized_rnn_tanh_cell(c_tensors, input.c_tensor, hx.c_tensor, w_ih.c_tensor, w_hh.c_tensor, b_ih.c_tensor, b_hh.c_tensor, packed_ih.c_tensor, packed_hh.c_tensor, col_offsets_ih.c_tensor, col_offsets_hh.c_tensor, scale_ih.c_scalar, scale_hh.c_scalar, zero_point_ih.c_scalar, zero_point_hh.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rand(self Tensor, size []int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rand(c_tensors, size.as_ptr(), size.len() int32, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rand_like(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rand_like(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rand_out(self Tensor, out Tensor, size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rand_out(c_tensors, out.c_tensor, size.as_ptr(), size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_randint(self Tensor, high int64, size []int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_randint(c_tensors, high, size.as_ptr(), size.len() int32, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_randint1(self Tensor, low int64, high int64, size []int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_randint1(c_tensors, low, high, size.as_ptr(), size.len() int32, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_randint_like(self Tensor, high int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_randint_like(c_tensors, self.c_tensor, high) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_randint_like1(self Tensor, low int64, high int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_randint_like1(c_tensors, self.c_tensor, low, high) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_randint_out(self Tensor, out Tensor, high int64, size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_randint_out(c_tensors, out.c_tensor, high, size.as_ptr(), size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_randint_out1(self Tensor, out Tensor, low int64, high int64, size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_randint_out1(c_tensors, out.c_tensor, low, high, size.as_ptr(), size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_randn(self Tensor, size []int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_randn(c_tensors, size.as_ptr(), size.len() int32, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_randn_like(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_randn_like(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_randn_out(self Tensor, out Tensor, size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_randn_out(c_tensors, out.c_tensor, size.as_ptr(), size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_random_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_random_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_random_1(self Tensor, to int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_random_1(c_tensors, self.c_tensor, to) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_random_2(self Tensor, from int64, to int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_random_2(c_tensors, self.c_tensor, from, to) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_randperm(self Tensor, n int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_randperm(c_tensors, n, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_randperm_out(self Tensor, out Tensor, n int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_randperm_out(c_tensors, out.c_tensor, n) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rangeScalar(self Tensor, start Scalar, end Scalar, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_range(c_tensors, start.c_scalar, end.c_scalar, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_range1Scalar(self Tensor, start Scalar, end Scalar, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_range1(c_tensors, start.c_scalar, end.c_scalar, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_range_outScalar(self Tensor, out Tensor, start Scalar, end Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_range_out(c_tensors, out.c_tensor, start.c_scalar, end.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_real(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_real(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_reciprocal(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_reciprocal(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_reciprocal_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_reciprocal_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_reciprocal_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_reciprocal_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_reflection_pad1d(self Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_reflection_pad1d(c_tensors, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_reflection_pad1d_backward(self Tensor, grad_output Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_reflection_pad1d_backward(c_tensors, grad_output.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_reflection_pad1d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_reflection_pad1d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_reflection_pad1d_out(self Tensor, out Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_reflection_pad1d_out(c_tensors, out.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_reflection_pad2d(self Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_reflection_pad2d(c_tensors, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_reflection_pad2d_backward(self Tensor, grad_output Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_reflection_pad2d_backward(c_tensors, grad_output.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_reflection_pad2d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_reflection_pad2d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_reflection_pad2d_out(self Tensor, out Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_reflection_pad2d_out(c_tensors, out.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_relu(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_relu(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_relu_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_relu_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_remainderScalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_remainder(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_remainder1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_remainder1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_remainder_Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_remainder_(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_remainder_1(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_remainder_1(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_remainder_outScalar(self Tensor, out Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_remainder_out(c_tensors, out.c_tensor, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_remainder_out1(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_remainder_out1(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_renormScalar(self Tensor, p Scalar, dim int64, maxnorm Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_renorm(c_tensors, self.c_tensor, p.c_scalar, dim, maxnorm.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_renorm_Scalar(self Tensor, p Scalar, dim int64, maxnorm Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_renorm_(c_tensors, self.c_tensor, p.c_scalar, dim, maxnorm.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_renorm_outScalar(self Tensor, out Tensor, p Scalar, dim int64, maxnorm Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_renorm_out(c_tensors, out.c_tensor, self.c_tensor, p.c_scalar, dim, maxnorm.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_repeat(self Tensor, repeats []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_repeat(c_tensors, self.c_tensor, repeats.as_ptr(), repeats.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_repeat_interleave(self Tensor, repeats Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_repeat_interleave(c_tensors, repeats.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_repeat_interleave1(self Tensor, repeats Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_repeat_interleave1(c_tensors, self.c_tensor, repeats.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_repeat_interleave2(self Tensor, repeats int64, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_repeat_interleave2(c_tensors, self.c_tensor, repeats, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_replication_pad1d(self Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_replication_pad1d(c_tensors, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_replication_pad1d_backward(self Tensor, grad_output Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_replication_pad1d_backward(c_tensors, grad_output.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_replication_pad1d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_replication_pad1d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_replication_pad1d_out(self Tensor, out Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_replication_pad1d_out(c_tensors, out.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_replication_pad2d(self Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_replication_pad2d(c_tensors, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_replication_pad2d_backward(self Tensor, grad_output Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_replication_pad2d_backward(c_tensors, grad_output.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_replication_pad2d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_replication_pad2d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_replication_pad2d_out(self Tensor, out Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_replication_pad2d_out(c_tensors, out.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_replication_pad3d(self Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_replication_pad3d(c_tensors, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_replication_pad3d_backward(self Tensor, grad_output Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_replication_pad3d_backward(c_tensors, grad_output.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_replication_pad3d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_replication_pad3d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_replication_pad3d_out(self Tensor, out Tensor, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_replication_pad3d_out(c_tensors, out.c_tensor, self.c_tensor, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_requires_grad_(self Tensor, internal_requires_grad bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_requires_grad_(c_tensors, self.c_tensor, if internal_requires_grad { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_reshape(self Tensor, shape []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_reshape(c_tensors, self.c_tensor, shape.as_ptr(), shape.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_reshape_as(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_reshape_as(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_resize_(self Tensor, size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_resize_(c_tensors, self.c_tensor, size.as_ptr(), size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_resize_as_(self Tensor, the_template Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_resize_as_(c_tensors, self.c_tensor, the_template.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rfft(self Tensor, signal_ndim int64, normalized bool, onesided bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rfft(c_tensors, self.c_tensor, signal_ndim, if normalized { 1 } else { 0 }, if onesided { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rnn_reluTensor(self Tensor, input Tensor, hx Tensor, params []Tensor, has_biases bool, num_layers int64, dropout float64, train bool, bidirectional bool, batch_first bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_rnn_relu(c_tensors, input.c_tensor, hx.c_tensor, ptr_list(params).as_ptr(), params.len() int32, if has_biases { 1 } else { 0 }, num_layers, dropout, if train { 1 } else { 0 }, if bidirectional { 1 } else { 0 }, if batch_first { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_rnn_relu1Tensor(self Tensor, data Tensor, batch_sizes Tensor, hx Tensor, params []Tensor, has_biases bool, num_layers int64, dropout float64, train bool, bidirectional bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_rnn_relu1(c_tensors, data.c_tensor, batch_sizes.c_tensor, hx.c_tensor, ptr_list(params).as_ptr(), params.len() int32, if has_biases { 1 } else { 0 }, num_layers, dropout, if train { 1 } else { 0 }, if bidirectional { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_rnn_relu_cellTensor(self Tensor, input Tensor, hx Tensor, w_ih Tensor, w_hh Tensor, b_ih TensorOption, b_hh TensorOption)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rnn_relu_cell(c_tensors, input.c_tensor, hx.c_tensor, w_ih.c_tensor, w_hh.c_tensor, b_ih.c_tensor), b_hh.c_tensor)) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rnn_tanhTensor(self Tensor, input Tensor, hx Tensor, params []Tensor, has_biases bool, num_layers int64, dropout float64, train bool, bidirectional bool, batch_first bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_rnn_tanh(c_tensors, input.c_tensor, hx.c_tensor, ptr_list(params).as_ptr(), params.len() int32, if has_biases { 1 } else { 0 }, num_layers, dropout, if train { 1 } else { 0 }, if bidirectional { 1 } else { 0 }, if batch_first { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_rnn_tanh1Tensor(self Tensor, data Tensor, batch_sizes Tensor, hx Tensor, params []Tensor, has_biases bool, num_layers int64, dropout float64, train bool, bidirectional bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_rnn_tanh1(c_tensors, data.c_tensor, batch_sizes.c_tensor, hx.c_tensor, ptr_list(params).as_ptr(), params.len() int32, if has_biases { 1 } else { 0 }, num_layers, dropout, if train { 1 } else { 0 }, if bidirectional { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_rnn_tanh_cellTensor(self Tensor, input Tensor, hx Tensor, w_ih Tensor, w_hh Tensor, b_ih TensorOption, b_hh TensorOption)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rnn_tanh_cell(c_tensors, input.c_tensor, hx.c_tensor, w_ih.c_tensor, w_hh.c_tensor, b_ih.c_tensor), b_hh.c_tensor)) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_roll(self Tensor, shifts []int64, dims []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_roll(c_tensors, self.c_tensor, shifts.as_ptr(), shifts.len() int32, dims.as_ptr(), dims.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rot90(self Tensor, k int64, dims []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rot90(c_tensors, self.c_tensor, k, dims.as_ptr(), dims.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_round(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_round(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_round_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_round_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_round_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_round_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rrelu(self Tensor, training bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rrelu(c_tensors, self.c_tensor, if training { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rrelu_(self Tensor, training bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rrelu_(c_tensors, self.c_tensor, if training { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rrelu_with_noise(self Tensor, noise Tensor, training bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rrelu_with_noise(c_tensors, self.c_tensor, noise.c_tensor, if training { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rrelu_with_noise_(self Tensor, noise Tensor, training bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rrelu_with_noise_(c_tensors, self.c_tensor, noise.c_tensor, if training { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rrelu_with_noise_backwardScalar(self Tensor, grad_output Tensor, noise Tensor, lower Scalar, upper Scalar, training bool, self_is_result bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rrelu_with_noise_backward(c_tensors, grad_output.c_tensor, self.c_tensor, noise.c_tensor, lower.c_scalar, upper.c_scalar, if training { 1 } else { 0 }, if self_is_result { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rrelu_with_noise_out(self Tensor, out Tensor, noise Tensor, training bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rrelu_with_noise_out(c_tensors, out.c_tensor, self.c_tensor, noise.c_tensor, if training { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rsqrt(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rsqrt(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rsqrt_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rsqrt_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rsqrt_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rsqrt_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rsub(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rsub(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_rsub1Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_rsub1(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_scalar_tensorScalar(self Tensor, s Scalar, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_scalar_tensor(c_tensors, s.c_scalar, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_scatter(self Tensor, dim int64, index Tensor, src Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_scatter(c_tensors, self.c_tensor, dim, index.c_tensor, src.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_scatter1Scalar(self Tensor, dim int64, index Tensor, value Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_scatter1(c_tensors, self.c_tensor, dim, index.c_tensor, value.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_scatter_(self Tensor, dim int64, index Tensor, src Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_scatter_(c_tensors, self.c_tensor, dim, index.c_tensor, src.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_scatter_1Scalar(self Tensor, dim int64, index Tensor, value Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_scatter_1(c_tensors, self.c_tensor, dim, index.c_tensor, value.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_scatter_add(self Tensor, dim int64, index Tensor, src Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_scatter_add(c_tensors, self.c_tensor, dim, index.c_tensor, src.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_scatter_add_(self Tensor, dim int64, index Tensor, src Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_scatter_add_(c_tensors, self.c_tensor, dim, index.c_tensor, src.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_select(self Tensor, dim int64, index int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_select(c_tensors, self.c_tensor, dim, index) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_selu(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_selu(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_selu_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_selu_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_set_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_set_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_set_1(self Tensor, source Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_set_1(c_tensors, self.c_tensor, source.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_set_requires_grad(self Tensor, r bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_set_requires_grad(c_tensors, self.c_tensor, if r { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sigmoid(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sigmoid(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sigmoid_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sigmoid_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sigmoid_backward(self Tensor, grad_output Tensor, output Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sigmoid_backward(c_tensors, grad_output.c_tensor, output.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sigmoid_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, output Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sigmoid_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, output.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sigmoid_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sigmoid_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sign(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sign(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sign_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sign_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sign_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sign_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sin(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sin(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sin_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sin_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sin_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sin_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sinh(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sinh(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sinh_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sinh_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sinh_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sinh_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_slice(self Tensor, dim int64, start int64, end int64, step int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_slice(c_tensors, self.c_tensor, dim, start, end, step) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_slogdet(self Tensor, )(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_slogdet(c_tensors, self.c_tensor) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_slow_conv3dTensor(self Tensor, weight Tensor, kernel_size []int64, bias TensorOption, stride []int64, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_slow_conv3d(c_tensors, self.c_tensor, weight.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_slow_conv3d_outTensor(self Tensor, out Tensor, weight Tensor, kernel_size []int64, bias TensorOption, stride []int64, padding []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_slow_conv3d_out(c_tensors, out.c_tensor, self.c_tensor, weight.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_slow_conv_dilated2dTensor(self Tensor, weight Tensor, kernel_size []int64, bias TensorOption, stride []int64, padding []int64, dilation []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_slow_conv_dilated2d(c_tensors, self.c_tensor, weight.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_slow_conv_dilated3dTensor(self Tensor, weight Tensor, kernel_size []int64, bias TensorOption, stride []int64, padding []int64, dilation []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_slow_conv_dilated3d(c_tensors, self.c_tensor, weight.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, dilation.as_ptr(), dilation.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_slow_conv_transpose2dTensor(self Tensor, weight Tensor, kernel_size []int64, bias TensorOption, stride []int64, padding []int64, output_padding []int64, dilation []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_slow_conv_transpose2d(c_tensors, self.c_tensor, weight.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, output_padding.as_ptr(), output_padding.len() int32, dilation.as_ptr(), dilation.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_slow_conv_transpose2d_outTensor(self Tensor, out Tensor, weight Tensor, kernel_size []int64, bias TensorOption, stride []int64, padding []int64, output_padding []int64, dilation []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_slow_conv_transpose2d_out(c_tensors, out.c_tensor, self.c_tensor, weight.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, output_padding.as_ptr(), output_padding.len() int32, dilation.as_ptr(), dilation.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_slow_conv_transpose3dTensor(self Tensor, weight Tensor, kernel_size []int64, bias TensorOption, stride []int64, padding []int64, output_padding []int64, dilation []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_slow_conv_transpose3d(c_tensors, self.c_tensor, weight.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, output_padding.as_ptr(), output_padding.len() int32, dilation.as_ptr(), dilation.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_slow_conv_transpose3d_outTensor(self Tensor, out Tensor, weight Tensor, kernel_size []int64, bias TensorOption, stride []int64, padding []int64, output_padding []int64, dilation []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_slow_conv_transpose3d_out(c_tensors, out.c_tensor, self.c_tensor, weight.c_tensor, kernel_size.as_ptr(), kernel_size.len() int32, bias.c_tensor), stride.as_ptr(), stride.len() int32, padding.as_ptr(), padding.len() int32, output_padding.as_ptr(), output_padding.len() int32, dilation.as_ptr(), dilation.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_smm(self Tensor, mat2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_smm(c_tensors, self.c_tensor, mat2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_smooth_l1_loss(self Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_smooth_l1_loss(c_tensors, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_smooth_l1_loss_backward(self Tensor, grad_output Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_smooth_l1_loss_backward(c_tensors, grad_output.c_tensor, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_smooth_l1_loss_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_smooth_l1_loss_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_smooth_l1_loss_out(self Tensor, out Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_smooth_l1_loss_out(c_tensors, out.c_tensor, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_soft_margin_loss(self Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_soft_margin_loss(c_tensors, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_soft_margin_loss_backward(self Tensor, grad_output Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_soft_margin_loss_backward(c_tensors, grad_output.c_tensor, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_soft_margin_loss_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_soft_margin_loss_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_soft_margin_loss_out(self Tensor, out Tensor, target Tensor, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_soft_margin_loss_out(c_tensors, out.c_tensor, self.c_tensor, target.c_tensor, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_softmax(self Tensor, dim int64, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_softmax(c_tensors, self.c_tensor, dim, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_softplus(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_softplus(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_softplus_backwardScalar(self Tensor, grad_output Tensor, beta Scalar, threshold Scalar, output Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_softplus_backward(c_tensors, grad_output.c_tensor, self.c_tensor, beta.c_scalar, threshold.c_scalar, output.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_softplus_backward_outScalar(self Tensor, grad_input Tensor, grad_output Tensor, beta Scalar, threshold Scalar, output Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_softplus_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, beta.c_scalar, threshold.c_scalar, output.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_softplus_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_softplus_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_softshrink(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_softshrink(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_softshrink_backwardScalar(self Tensor, grad_output Tensor, lambd Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_softshrink_backward(c_tensors, grad_output.c_tensor, self.c_tensor, lambd.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_softshrink_backward_outScalar(self Tensor, grad_input Tensor, grad_output Tensor, lambd Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_softshrink_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, self.c_tensor, lambd.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_softshrink_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_softshrink_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_solve(self Tensor, a Tensor)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_solve(c_tensors, self.c_tensor, a.c_tensor) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_solve_out(self Tensor, solution Tensor, lu Tensor, a Tensor)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_solve_out(c_tensors, solution.c_tensor, lu.c_tensor, self.c_tensor, a.c_tensor) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_sort(self Tensor, dim int64, descending bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_sort(c_tensors, self.c_tensor, dim, if descending { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_sort_out(self Tensor, values Tensor, indices Tensor, dim int64, descending bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_sort_out(c_tensors, values.c_tensor, indices.c_tensor, self.c_tensor, dim, if descending { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_sparse_coo_tensor(self Tensor, size []int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sparse_coo_tensor(c_tensors, size.as_ptr(), size.len() int32, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sparse_coo_tensor1(self Tensor, indices Tensor, values Tensor, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sparse_coo_tensor1(c_tensors, indices.c_tensor, values.c_tensor, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sparse_coo_tensor2(self Tensor, indices Tensor, values Tensor, size []int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sparse_coo_tensor2(c_tensors, indices.c_tensor, values.c_tensor, size.as_ptr(), size.len() int32, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sparse_mask(self Tensor, mask Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sparse_mask(c_tensors, self.c_tensor, mask.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sparse_resize_(self Tensor, size []int64, sparse_dim int64, dense_dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sparse_resize_(c_tensors, self.c_tensor, size.as_ptr(), size.len() int32, sparse_dim, dense_dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sparse_resize_and_clear_(self Tensor, size []int64, sparse_dim int64, dense_dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sparse_resize_and_clear_(c_tensors, self.c_tensor, size.as_ptr(), size.len() int32, sparse_dim, dense_dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_split(self Tensor, split_size int64, dim int64)(error, []Tensor) { 
        c_tensors := unsafe_torch_err!({atg_split(self.c_tensor, split_size, dim)}) 
        var r__ []Tensor 
        i := 0 
        for { 
            c__ := unsafe{*c_tensors.add(i)} 
            if c__.is_null() { break } 
            r__ = append(r__, Tensor {C_tensor: c__}) 
            i += 1 
        } 
        return r__ 
} 

func f_split_with_sizes(self Tensor, split_sizes []int64, dim int64)(error, []Tensor) { 
        c_tensors := unsafe_torch_err!({atg_split_with_sizes(self.c_tensor, split_sizes.as_ptr(), split_sizes.len() int32, dim)}) 
        var r__ []Tensor 
        i := 0 
        for { 
            c__ := unsafe{*c_tensors.add(i)} 
            if c__.is_null() { break } 
            r__ = append(r__, Tensor {C_tensor: c__}) 
            i += 1 
        } 
        return r__ 
} 

func f_sqrt(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sqrt(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sqrt_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sqrt_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sqrt_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sqrt_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_square(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_square(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_square_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_square_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_squeeze(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_squeeze(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_squeeze1(self Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_squeeze1(c_tensors, self.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_squeeze_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_squeeze_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_squeeze_1(self Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_squeeze_1(c_tensors, self.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sspaddmm(self Tensor, mat1 Tensor, mat2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sspaddmm(c_tensors, self.c_tensor, mat1.c_tensor, mat2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sspaddmm_out(self Tensor, out Tensor, mat1 Tensor, mat2 Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sspaddmm_out(c_tensors, out.c_tensor, self.c_tensor, mat1.c_tensor, mat2.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_stackTensor(self Tensor, tensors []Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_stack(c_tensors, ptr_list(tensors).as_ptr(), tensors.len() int32, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_stack_outTensor(self Tensor, out Tensor, tensors []Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_stack_out(c_tensors, out.c_tensor, ptr_list(tensors).as_ptr(), tensors.len() int32, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_std(self Tensor, unbiased bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_std(c_tensors, self.c_tensor, if unbiased { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_std1(self Tensor, dim []int64, unbiased bool, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_std1(c_tensors, self.c_tensor, dim.as_ptr(), dim.len() int32, if unbiased { 1 } else { 0 }, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_std_mean(self Tensor, unbiased bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_std_mean(c_tensors, self.c_tensor, if unbiased { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_std_mean1(self Tensor, dim []int64, unbiased bool, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_std_mean1(c_tensors, self.c_tensor, dim.as_ptr(), dim.len() int32, if unbiased { 1 } else { 0 }, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_std_out(self Tensor, out Tensor, dim []int64, unbiased bool, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_std_out(c_tensors, out.c_tensor, self.c_tensor, dim.as_ptr(), dim.len() int32, if unbiased { 1 } else { 0 }, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_stftTensor(self Tensor, n_fft int64, hop_length int64, win_length int64, window TensorOption, normalized bool, onesided bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_stft(c_tensors, self.c_tensor, n_fft, hop_length, win_length, window.c_tensor), if normalized { 1 } else { 0 }, if onesided { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sub(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sub(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sub1Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sub1(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sub_(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sub_(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sub_1Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sub_1(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sub_out(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sub_out(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sum(self Tensor, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sum(c_tensors, self.c_tensor, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sum1(self Tensor, dim []int64, keepdim bool, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sum1(c_tensors, self.c_tensor, dim.as_ptr(), dim.len() int32, if keepdim { 1 } else { 0 }, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sum_out(self Tensor, out Tensor, dim []int64, keepdim bool, dtype Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sum_out(c_tensors, out.c_tensor, self.c_tensor, dim.as_ptr(), dim.len() int32, if keepdim { 1 } else { 0 }, dtype.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_sum_to_size(self Tensor, size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_sum_to_size(c_tensors, self.c_tensor, size.as_ptr(), size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_svd(self Tensor, some bool, compute_uv bool)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg_svd(c_tensors, self.c_tensor, if some { 1 } else { 0 }, if compute_uv { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_svd_out(self Tensor, u Tensor, s Tensor, v Tensor, some bool, compute_uv bool)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg_svd_out(c_tensors, u.c_tensor, s.c_tensor, v.c_tensor, self.c_tensor, if some { 1 } else { 0 }, if compute_uv { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_symeig(self Tensor, eigenvectors bool, upper bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_symeig(c_tensors, self.c_tensor, if eigenvectors { 1 } else { 0 }, if upper { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_symeig_out(self Tensor, e Tensor, v Tensor, eigenvectors bool, upper bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_symeig_out(c_tensors, e.c_tensor, v.c_tensor, self.c_tensor, if eigenvectors { 1 } else { 0 }, if upper { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_tr(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_t(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_t_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_t_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_take(self Tensor, index Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_take(c_tensors, self.c_tensor, index.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_take_out(self Tensor, out Tensor, index Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_take_out(c_tensors, out.c_tensor, self.c_tensor, index.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_tan(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_tan(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_tan_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_tan_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_tan_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_tan_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_tanh(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_tanh(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_tanh_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_tanh_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_tanh_backward(self Tensor, grad_output Tensor, output Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_tanh_backward(c_tensors, grad_output.c_tensor, output.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_tanh_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, output Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_tanh_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, output.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_tanh_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_tanh_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_tensordot(self Tensor, other Tensor, dims_self []int64, dims_other []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_tensordot(c_tensors, self.c_tensor, other.c_tensor, dims_self.as_ptr(), dims_self.len() int32, dims_other.as_ptr(), dims_other.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_thresholdScalar(self Tensor, threshold Scalar, value Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_threshold(c_tensors, self.c_tensor, threshold.c_scalar, value.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_threshold_Scalar(self Tensor, threshold Scalar, value Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_threshold_(c_tensors, self.c_tensor, threshold.c_scalar, value.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_threshold_backwardScalar(self Tensor, grad_output Tensor, threshold Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_threshold_backward(c_tensors, grad_output.c_tensor, self.c_tensor, threshold.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_threshold_outScalar(self Tensor, out Tensor, threshold Scalar, value Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_threshold_out(c_tensors, out.c_tensor, self.c_tensor, threshold.c_scalar, value.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_to(self Tensor, device Device)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_to(c_tensors, self.c_tensor, device.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_to1(self Tensor, options (Kind, Device), non_blocking bool, copy bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_to1(c_tensors, self.c_tensor, options.0.c_int(), options.1.c_int(), if non_blocking { 1 } else { 0 }, if copy { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_to2(self Tensor, dtype Kind, non_blocking bool, copy bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_to2(c_tensors, self.c_tensor, dtype.c_int(), if non_blocking { 1 } else { 0 }, if copy { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_to3(self Tensor, other Tensor, non_blocking bool, copy bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_to3(c_tensors, self.c_tensor, other.c_tensor, if non_blocking { 1 } else { 0 }, if copy { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_to4(self Tensor, device Device, dtype Kind, non_blocking bool, copy bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_to4(c_tensors, self.c_tensor, device.c_int(), dtype.c_int(), if non_blocking { 1 } else { 0 }, if copy { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_to_dense(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_to_dense(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_to_dense_backward(self Tensor, grad Tensor, input Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_to_dense_backward(c_tensors, grad.c_tensor, input.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_to_mkldnn(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_to_mkldnn(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_to_mkldnn_backward(self Tensor, grad Tensor, input Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_to_mkldnn_backward(c_tensors, grad.c_tensor, input.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_to_sparse(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_to_sparse(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_to_sparse1(self Tensor, sparse_dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_to_sparse1(c_tensors, self.c_tensor, sparse_dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_topk(self Tensor, k int64, dim int64, largest bool, sorted bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_topk(c_tensors, self.c_tensor, k, dim, if largest { 1 } else { 0 }, if sorted { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_topk_out(self Tensor, values Tensor, indices Tensor, k int64, dim int64, largest bool, sorted bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_topk_out(c_tensors, values.c_tensor, indices.c_tensor, self.c_tensor, k, dim, if largest { 1 } else { 0 }, if sorted { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_totype(self Tensor, scalar_type Kind)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_totype(c_tensors, self.c_tensor, scalar_type.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_trace(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_trace(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_transpose(self Tensor, dim0 int64, dim1 int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_transpose(c_tensors, self.c_tensor, dim0, dim1) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_transpose_(self Tensor, dim0 int64, dim1 int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_transpose_(c_tensors, self.c_tensor, dim0, dim1) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_trapz(self Tensor, y Tensor, x Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_trapz(c_tensors, y.c_tensor, x.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_trapz1(self Tensor, y Tensor, dx float64, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_trapz1(c_tensors, y.c_tensor, dx, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_triangular_solve(self Tensor, a Tensor, upper bool, transpose bool, unitriangular bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_triangular_solve(c_tensors, self.c_tensor, a.c_tensor, if upper { 1 } else { 0 }, if transpose { 1 } else { 0 }, if unitriangular { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_triangular_solve_out(self Tensor, x Tensor, m Tensor, a Tensor, upper bool, transpose bool, unitriangular bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_triangular_solve_out(c_tensors, x.c_tensor, m.c_tensor, self.c_tensor, a.c_tensor, if upper { 1 } else { 0 }, if transpose { 1 } else { 0 }, if unitriangular { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_tril(self Tensor, diagonal int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_tril(c_tensors, self.c_tensor, diagonal) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_tril_(self Tensor, diagonal int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_tril_(c_tensors, self.c_tensor, diagonal) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_tril_indices(self Tensor, row int64, col int64, offset int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_tril_indices(c_tensors, row, col, offset, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_tril_out(self Tensor, out Tensor, diagonal int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_tril_out(c_tensors, out.c_tensor, self.c_tensor, diagonal) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_triplet_margin_loss(self Tensor, anchor Tensor, positive Tensor, negative Tensor, margin float64, p float64, eps float64, swap bool, reduction int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_triplet_margin_loss(c_tensors, anchor.c_tensor, positive.c_tensor, negative.c_tensor, margin, p, eps, if swap { 1 } else { 0 }, reduction.to_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_triu(self Tensor, diagonal int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_triu(c_tensors, self.c_tensor, diagonal) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_triu_(self Tensor, diagonal int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_triu_(c_tensors, self.c_tensor, diagonal) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_triu_indices(self Tensor, row int64, col int64, offset int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_triu_indices(c_tensors, row, col, offset, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_triu_out(self Tensor, out Tensor, diagonal int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_triu_out(c_tensors, out.c_tensor, self.c_tensor, diagonal) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_true_divide(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_true_divide(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_true_divide1Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_true_divide1(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_true_divide_(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_true_divide_(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_true_divide_1Scalar(self Tensor, other Scalar)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_true_divide_1(c_tensors, self.c_tensor, other.c_scalar) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_true_divide_out(self Tensor, out Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_true_divide_out(c_tensors, out.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_trunc(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_trunc(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_trunc_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_trunc_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_trunc_out(self Tensor, out Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_trunc_out(c_tensors, out.c_tensor, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_type_as(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_type_as(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_unbind(self Tensor, dim int64)(error, []Tensor) { 
        c_tensors := unsafe_torch_err!({atg_unbind(self.c_tensor, dim)}) 
        var r__ []Tensor 
        i := 0 
        for { 
            c__ := unsafe{*c_tensors.add(i)} 
            if c__.is_null() { break } 
            r__ = append(r__, Tensor {C_tensor: c__}) 
            i += 1 
        } 
        return r__ 
} 

func f_unfold(self Tensor, dimension int64, size int64, step int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_unfold(c_tensors, self.c_tensor, dimension, size, step) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_uniform_(self Tensor, from float64, to float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_uniform_(c_tensors, self.c_tensor, from, to) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_unique_consecutive(self Tensor, return_inverse bool, return_counts bool, dim int64)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg_unique_consecutive(c_tensors, self.c_tensor, if return_inverse { 1 } else { 0 }, if return_counts { 1 } else { 0 }, dim) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_unique_dim(self Tensor, dim int64, sorted bool, return_inverse bool, return_counts bool)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg_unique_dim(c_tensors, self.c_tensor, dim, if sorted { 1 } else { 0 }, if return_inverse { 1 } else { 0 }, if return_counts { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_unique_dim_consecutive(self Tensor, dim int64, return_inverse bool, return_counts bool)(error, (Tensor, Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 3) 
    unsafe_torch_err({ 
        atg_unique_dim_consecutive(c_tensors, self.c_tensor, dim, if return_inverse { 1 } else { 0 }, if return_counts { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }, Tensor { C_tensor: c_tensors[2] }) 
} 

func f_unsqueeze(self Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_unsqueeze(c_tensors, self.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_unsqueeze_(self Tensor, dim int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_unsqueeze_(c_tensors, self.c_tensor, dim) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_bicubic2d(self Tensor, output_size []int64, align_corners bool, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_bicubic2d(c_tensors, self.c_tensor, output_size.as_ptr(), output_size.len() int32, if align_corners { 1 } else { 0 }, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_bicubic2d_backward(self Tensor, grad_output Tensor, output_size []int64, input_size []int64, align_corners bool, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_bicubic2d_backward(c_tensors, grad_output.c_tensor, output_size.as_ptr(), output_size.len() int32, input_size.as_ptr(), input_size.len() int32, if align_corners { 1 } else { 0 }, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_bicubic2d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, output_size []int64, input_size []int64, align_corners bool, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_bicubic2d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, output_size.as_ptr(), output_size.len() int32, input_size.as_ptr(), input_size.len() int32, if align_corners { 1 } else { 0 }, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_bicubic2d_out(self Tensor, out Tensor, output_size []int64, align_corners bool, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_bicubic2d_out(c_tensors, out.c_tensor, self.c_tensor, output_size.as_ptr(), output_size.len() int32, if align_corners { 1 } else { 0 }, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_bilinear2d(self Tensor, output_size []int64, align_corners bool, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_bilinear2d(c_tensors, self.c_tensor, output_size.as_ptr(), output_size.len() int32, if align_corners { 1 } else { 0 }, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_bilinear2d_backward(self Tensor, grad_output Tensor, output_size []int64, input_size []int64, align_corners bool, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_bilinear2d_backward(c_tensors, grad_output.c_tensor, output_size.as_ptr(), output_size.len() int32, input_size.as_ptr(), input_size.len() int32, if align_corners { 1 } else { 0 }, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_bilinear2d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, output_size []int64, input_size []int64, align_corners bool, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_bilinear2d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, output_size.as_ptr(), output_size.len() int32, input_size.as_ptr(), input_size.len() int32, if align_corners { 1 } else { 0 }, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_bilinear2d_out(self Tensor, out Tensor, output_size []int64, align_corners bool, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_bilinear2d_out(c_tensors, out.c_tensor, self.c_tensor, output_size.as_ptr(), output_size.len() int32, if align_corners { 1 } else { 0 }, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_linear1d(self Tensor, output_size []int64, align_corners bool, scales float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_linear1d(c_tensors, self.c_tensor, output_size.as_ptr(), output_size.len() int32, if align_corners { 1 } else { 0 }, scales) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_linear1d_backward(self Tensor, grad_output Tensor, output_size []int64, input_size []int64, align_corners bool, scales float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_linear1d_backward(c_tensors, grad_output.c_tensor, output_size.as_ptr(), output_size.len() int32, input_size.as_ptr(), input_size.len() int32, if align_corners { 1 } else { 0 }, scales) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_linear1d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, output_size []int64, input_size []int64, align_corners bool, scales float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_linear1d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, output_size.as_ptr(), output_size.len() int32, input_size.as_ptr(), input_size.len() int32, if align_corners { 1 } else { 0 }, scales) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_linear1d_out(self Tensor, out Tensor, output_size []int64, align_corners bool, scales float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_linear1d_out(c_tensors, out.c_tensor, self.c_tensor, output_size.as_ptr(), output_size.len() int32, if align_corners { 1 } else { 0 }, scales) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_nearest1d(self Tensor, output_size []int64, scales float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_nearest1d(c_tensors, self.c_tensor, output_size.as_ptr(), output_size.len() int32, scales) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_nearest1d_backward(self Tensor, grad_output Tensor, output_size []int64, input_size []int64, scales float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_nearest1d_backward(c_tensors, grad_output.c_tensor, output_size.as_ptr(), output_size.len() int32, input_size.as_ptr(), input_size.len() int32, scales) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_nearest1d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, output_size []int64, input_size []int64, scales float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_nearest1d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, output_size.as_ptr(), output_size.len() int32, input_size.as_ptr(), input_size.len() int32, scales) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_nearest1d_out(self Tensor, out Tensor, output_size []int64, scales float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_nearest1d_out(c_tensors, out.c_tensor, self.c_tensor, output_size.as_ptr(), output_size.len() int32, scales) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_nearest2d(self Tensor, output_size []int64, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_nearest2d(c_tensors, self.c_tensor, output_size.as_ptr(), output_size.len() int32, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_nearest2d_backward(self Tensor, grad_output Tensor, output_size []int64, input_size []int64, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_nearest2d_backward(c_tensors, grad_output.c_tensor, output_size.as_ptr(), output_size.len() int32, input_size.as_ptr(), input_size.len() int32, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_nearest2d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, output_size []int64, input_size []int64, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_nearest2d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, output_size.as_ptr(), output_size.len() int32, input_size.as_ptr(), input_size.len() int32, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_nearest2d_out(self Tensor, out Tensor, output_size []int64, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_nearest2d_out(c_tensors, out.c_tensor, self.c_tensor, output_size.as_ptr(), output_size.len() int32, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_nearest3d(self Tensor, output_size []int64, scales_d float64, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_nearest3d(c_tensors, self.c_tensor, output_size.as_ptr(), output_size.len() int32, scales_d, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_nearest3d_backward(self Tensor, grad_output Tensor, output_size []int64, input_size []int64, scales_d float64, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_nearest3d_backward(c_tensors, grad_output.c_tensor, output_size.as_ptr(), output_size.len() int32, input_size.as_ptr(), input_size.len() int32, scales_d, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_nearest3d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, output_size []int64, input_size []int64, scales_d float64, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_nearest3d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, output_size.as_ptr(), output_size.len() int32, input_size.as_ptr(), input_size.len() int32, scales_d, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_nearest3d_out(self Tensor, out Tensor, output_size []int64, scales_d float64, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_nearest3d_out(c_tensors, out.c_tensor, self.c_tensor, output_size.as_ptr(), output_size.len() int32, scales_d, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_trilinear3d(self Tensor, output_size []int64, align_corners bool, scales_d float64, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_trilinear3d(c_tensors, self.c_tensor, output_size.as_ptr(), output_size.len() int32, if align_corners { 1 } else { 0 }, scales_d, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_trilinear3d_backward(self Tensor, grad_output Tensor, output_size []int64, input_size []int64, align_corners bool, scales_d float64, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_trilinear3d_backward(c_tensors, grad_output.c_tensor, output_size.as_ptr(), output_size.len() int32, input_size.as_ptr(), input_size.len() int32, if align_corners { 1 } else { 0 }, scales_d, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_trilinear3d_backward_out(self Tensor, grad_input Tensor, grad_output Tensor, output_size []int64, input_size []int64, align_corners bool, scales_d float64, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_trilinear3d_backward_out(c_tensors, grad_input.c_tensor, grad_output.c_tensor, output_size.as_ptr(), output_size.len() int32, input_size.as_ptr(), input_size.len() int32, if align_corners { 1 } else { 0 }, scales_d, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_upsample_trilinear3d_out(self Tensor, out Tensor, output_size []int64, align_corners bool, scales_d float64, scales_h float64, scales_w float64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_upsample_trilinear3d_out(c_tensors, out.c_tensor, self.c_tensor, output_size.as_ptr(), output_size.len() int32, if align_corners { 1 } else { 0 }, scales_d, scales_h, scales_w) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_values(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_values(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_var(self Tensor, unbiased bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_var(c_tensors, self.c_tensor, if unbiased { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_var1(self Tensor, dim []int64, unbiased bool, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_var1(c_tensors, self.c_tensor, dim.as_ptr(), dim.len() int32, if unbiased { 1 } else { 0 }, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_var_mean(self Tensor, unbiased bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_var_mean(c_tensors, self.c_tensor, if unbiased { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_var_mean1(self Tensor, dim []int64, unbiased bool, keepdim bool)(error, (Tensor, Tensor)) { 
    var c_tensors []C_tensor = make([]C_tensor, 2) 
    unsafe_torch_err({ 
        atg_var_mean1(c_tensors, self.c_tensor, dim.as_ptr(), dim.len() int32, if unbiased { 1 } else { 0 }, if keepdim { 1 } else { 0 }) 
    }) 
        return (Tensor { C_tensor: c_tensors[0] }, Tensor { C_tensor: c_tensors[1] }) 
} 

func f_var_out(self Tensor, out Tensor, dim []int64, unbiased bool, keepdim bool)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_var_out(c_tensors, out.c_tensor, self.c_tensor, dim.as_ptr(), dim.len() int32, if unbiased { 1 } else { 0 }, if keepdim { 1 } else { 0 }) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_view_(self Tensor, size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_view(c_tensors, self.c_tensor, size.as_ptr(), size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_view_as(self Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_view_as(c_tensors, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_where_(self Tensor, condition Tensor)(error, []Tensor) { 
        c_tensors := unsafe_torch_err!({atg_where(condition.c_tensor)}) 
        var r__ []Tensor 
        i := 0 
        for { 
            c__ := unsafe{*c_tensors.add(i)} 
            if c__.is_null() { break } 
            r__ = append(r__, Tensor {C_tensor: c__}) 
            i += 1 
        } 
        return r__ 
} 

func f_where1(self Tensor, condition Tensor, other Tensor)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_where1(c_tensors, condition.c_tensor, self.c_tensor, other.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_zero_(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_zero_(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_zeros(self Tensor, size []int64, options (Kind, Device))(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_zeros(c_tensors, size.as_ptr(), size.len() int32, options.0.c_int(), options.1.c_int()) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_zeros_like(self Tensor, )(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_zeros_like(c_tensors, self.c_tensor) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 

func f_zeros_out(self Tensor, out Tensor, size []int64)(error, Tensor) { 
    var c_tensors []C_tensor = make([]C_tensor, 1) 
    unsafe_torch_err({ 
        atg_zeros_out(c_tensors, out.c_tensor, size.as_ptr(), size.len() int32) 
    }) 
        return Tensor { C_tensor: c_tensors[0] } 
} 
